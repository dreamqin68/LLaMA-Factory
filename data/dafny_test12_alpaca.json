[
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Op = Mul | Add\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\ndatatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\nfunction Unit(op: Op): nat \n\n{\n  match op case Add => 0 case Mul => 1\n}\n\nfunction EvalList(op: Op, args: List<Expr>, env: map<string, nat>): nat\n  decreases args, op, env\n\n{\n  match args {\n    case Nil => Unit(op)\n    case Cons(e, tail) =>\n      var v0, v1 := Eval(e, env), EvalList(op, tail, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1\n  }\n}\n\nfunction Eval(e: Expr, env: map<string, nat>): nat\n\n{\n  match e {\n    case Const(c) => c\n    case Var(s) => if s in env then env[s] else 0\n    case Node(op, args) => EvalList(op, args, env)\n  }\n}\n\nfunction SubstituteList(es: List<Expr>, n: string, c: nat): List<Expr>\n\n{\n  match es\n  case Nil => Nil\n  case Cons(head, tail) => Cons(Substitute(head, n, c), SubstituteList(tail, n, c))\n}\n\nfunction Substitute(e: Expr, n: string, c: nat): Expr\n\n{\n  match e\n  case Const(_) => e\n  case Var(s) => if s == n then Const(c) else e\n  case Node(op, args) => Node(op, SubstituteList(args, n, c))\n}\n\nKnown Properties:\nlemma EvalSubstituteListCorrect(op: Op, args: List<Expr>, n: string, c: nat, env: map<string, nat>)\n  ensures EvalList(op, SubstituteList(args, n, c), env) == EvalList(op, args, env[n := c])\n  decreases args, op, n, c, env\n\n{\n  match args\n  case Nil => {}\n  case Cons(head, tail) => {\n    // Ex 5.15\n    calc {\n      EvalList(op, SubstituteList(args, n, c), env);\n    ==  // defn SubstituteList\n      EvalList(op, Cons(Substitute(head, n, c), SubstituteList(tail, n, c)), env);\n    == // unfold defn EvalList\n      EvalList(op, Cons(Substitute(head, n, c), SubstituteList(tail, n, c)), env);\n    ==\n      (match op\n       case Add => Eval(Substitute(head, n, c), env) + EvalList(op, SubstituteList(tail, n, c), env)\n       case Mul => Eval(Substitute(head, n, c), env) * EvalList(op, SubstituteList(tail, n, c), env));\n      (match op\n       case Add => Eval(head, env[n := c]) + EvalList(op, SubstituteList(tail, n, c), env)\n       case Mul => Eval(head, env[n := c]) * EvalList(op, SubstituteList(tail, n, c), env));\n    == \n    // { EvalSubstituteListCorrect(op, tail, n, c, env); }\n      (match op\n       case Add => Eval(head, env[n := c]) + EvalList(op, tail, env[n := c])\n       case Mul => Eval(head, env[n := c]) * EvalList(op, tail, env[n := c]));\n    == // fold defn Eval/EvalList\n      EvalList(op, args, env[n := c]);\n    }\n  }\n}\n\n\n\nProperty:\nlemma EvalSubstituteCorrect(e: Expr, n: string, c: nat, env: map<string, nat>)\n  ensures Eval(Substitute(e, n, c), env) == Eval(e, env[n := c])\n\n\n",
        "output": "{\n  match e\n  case Const(_) => {}\n  case Var(s) => {\n    calc {\n      Eval(Substitute(e, n, c), env);\n      Eval(if s == n then Const(c) else e, env);\n      if s == n then Eval(Const(c), env) else Eval(e, env);\n      if s == n then c else Eval(e, env);\n      if s == n then c else Eval(e, env[n := c]);\n      if s == n then Eval(e, env[n := c]) else Eval(e, env[n := c]);\n      Eval(e, env[n := c]);\n    }\n  }\n  case Node(op, args) => {\n    EvalSubstituteListCorrect(op, args, n, c, env);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Op = Mul | Add\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\ndatatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\nfunction Unit(op: Op): nat \n\n{\n  match op case Add => 0 case Mul => 1\n}\n\nfunction EvalList(op: Op, args: List<Expr>, env: map<string, nat>): nat\n  decreases args, op, env\n\n{\n  match args {\n    case Nil => Unit(op)\n    case Cons(e, tail) =>\n      var v0, v1 := Eval(e, env), EvalList(op, tail, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1\n  }\n}\n\nfunction Eval(e: Expr, env: map<string, nat>): nat\n\n{\n  match e {\n    case Const(c) => c\n    case Var(s) => if s in env then env[s] else 0\n    case Node(op, args) => EvalList(op, args, env)\n  }\n}\n\nfunction Shorten(op: Op, args: List<Expr>): Expr \n{\n  match args\n  case Nil => Const(Unit(op))\n  // shorten the singleton list\n  case Cons(head, Nil) => head\n  // reduce units from the head\n  case _ => Node(op, args)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma ShortenCorrect(args: List<Expr>, op: Op, env: map<string, nat>)\n  ensures Eval(Shorten(op, args), env) == Eval(Node(op, args), env)\n\n\n",
        "output": "{\n  match args\n  case Nil => {}\n  case Cons(head, Nil) => {\n    calc {\n      Eval(Node(op, args), env);\n      EvalList(op, Cons(head, Nil), env);\n      Eval(head, env);\n    }\n  }\n  case _ => {}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nghost predicate Ordered(xs: List<int>) \n{\n    match xs\n    case Nil => true\n    case Cons(_, Nil) => true\n    case Cons(hd0, Cons(hd1, _)) => (hd0 <= hd1) && Ordered(xs.tail)\n}\n\nfunction Length<T>(xs: List<T>): int\n  ensures Length(xs) >= 0\n\n{\n    match xs\n    case Nil => 0\n    case Cons(_, tl) => 1 + Length(tl)\n}\n\nfunction At<T>(xs: List, i: nat): T\n  requires i < Length(xs)\n\n{\n    if i == 0 then xs.head else At(xs.tail, i - 1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma AllOrdered(xs: List<int>, i: nat, j: nat)\n  requires Ordered(xs) && i <= j < Length(xs)\n  ensures At(xs, i) <= At(xs, j)\n\n\n",
        "output": "{\n    if i != 0 {\n        AllOrdered(xs.tail, i - 1, j - 1);\n    } else if i == j {\n        assert i == 0 && j == 0;\n    } else {\n        assert i == 0 && i < j;\n        assert xs.head <= xs.tail.head;\n        AllOrdered(xs.tail, 0, j - 1);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nghost function Count<T>(xs: List<T>, p: T): int\n  ensures Count(xs, p) >= 0\n\n{\n    match xs\n    case Nil => 0\n    case Cons(hd, tl) => (if hd == p then 1 else 0) + Count(tl, p)\n}\n\nghost function Project<T>(xs: List<T>, p: T): List<T> \n{\n    match xs\n    case Nil => Nil\n    case Cons(hd, tl) => if hd == p then Cons(hd, Project(tl, p)) else Project(tl, p)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma CountProject<T>(xs: List<T>, ys: List<T>, p: T)\n  requires Project(xs, p) == Project(ys, p)\n  ensures Count(xs, p) == Count(ys, p)\n\n\n",
        "output": "{\n    match xs\n    case Nil => {\n        match ys\n        case Nil => {}\n        case Cons(yhd, ytl) => {\n            assert Count(xs, p) == 0;\n            assert Project(xs, p) == Nil;\n            assert Project(ys, p) == Nil;\n            assert yhd != p;\n            CountProject(xs, ytl, p);\n        }\n    }\n    case Cons(xhd, xtl) => {\n        match ys\n        case Nil => {\n            assert Count(ys, p) == 0;\n            CountProject(xtl, ys, p);\n        }\n        case Cons(yhd, ytl) => {\n            if xhd == p && yhd == p {\n                assert Count(xs, p) == 1 + Count(xtl, p);\n                assert Count(ys, p) == 1 + Count(ytl, p);\n                assert Project(xtl, p) == Project(ytl, p);\n                CountProject(xtl, ytl, p);\n            } else if xhd != p && yhd == p {\n                assert Count(xs, p) == Count(xtl, p);\n                assert Count(ys, p) == 1 + Count(ytl, p);\n                CountProject(xtl, ys, p);\n            } else if xhd == p && yhd != p {\n                assert Count(ys, p) == Count(ytl, p);\n                assert Count(xs, p) == 1 + Count(xtl, p);\n                CountProject(xs, ytl, p);\n            } else {\n                CountProject(xtl, ytl, p);\n            }\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Insert(x: int, xs: List<int>): List<int>\n\n{\n    match xs\n    case Nil => Cons(x, Nil)\n    case Cons(hd, tl) => if x < hd then Cons(x, xs) else Cons(hd, Insert(x, tl))\n}\n\nfunction InsertionSort(xs: List<int>): List<int>\n\n{\n    match xs\n    case Nil => Nil\n    case Cons(x, rest) => Insert(x, InsertionSort(rest))\n}\n\nghost predicate Ordered(xs: List<int>) \n{\n    match xs\n    case Nil => true\n    case Cons(_, Nil) => true\n    case Cons(hd0, Cons(hd1, _)) => (hd0 <= hd1) && Ordered(xs.tail)\n}\n\nKnown Properties:\nlemma InsertOrdered(y: int, xs: List<int>)\n  requires Ordered(xs)\n  ensures Ordered(Insert(y, xs))\n\n{}\n\n\n\nProperty:\nlemma InsertionSortOrdered(xs: List<int>)\n  ensures Ordered(InsertionSort(xs))\n\n\n",
        "output": "{\n    match xs\n    case Nil =>\n    case Cons(hd, tl) => {\n        InsertionSortOrdered(tl);\n        InsertOrdered(hd, InsertionSort(tl));\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nghost function Project<T>(xs: List<T>, p: T): List<T> \n{\n    match xs\n    case Nil => Nil\n    case Cons(hd, tl) => if hd == p then Cons(hd, Project(tl, p)) else Project(tl, p)\n}\n\nfunction Insert(x: int, xs: List<int>): List<int>\n\n{\n    match xs\n    case Nil => Cons(x, Nil)\n    case Cons(hd, tl) => if x < hd then Cons(x, xs) else Cons(hd, Insert(x, tl))\n}\n\nfunction InsertionSort(xs: List<int>): List<int>\n\n{\n    match xs\n    case Nil => Nil\n    case Cons(x, rest) => Insert(x, InsertionSort(rest))\n}\n\nKnown Properties:\nlemma InsertSameElements(y: int, xs: List<int>, p: int)\n  ensures Project(Cons(y, xs), p) == Project(Insert(y, xs), p)\n\n{}\n\n\n\nProperty:\nlemma InsertionSortSameElements(xs: List<int>, p: int)\n  ensures Project(xs, p) == Project(InsertionSort(xs), p)\n\n\n",
        "output": "{\n    match xs\n    case Nil =>\n    case Cons(hd, tl) => {\n        InsertSameElements(hd, InsertionSort(tl), p);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype BraunTree =\n        | Leaf\n        | Node(x: int, left: BraunTree, right: BraunTree)\n\ntype PQueue = BraunTree\n\nghost predicate IsBinaryHeap(pq: PQueue)\n\n{\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n        IsBinaryHeap(left) && IsBinaryHeap(right) &&\n        (left.Leaf? || x <= left.x) &&\n        (right.Leaf? || x <= right.x)\n}\n\nghost function Elements(pq: PQueue): multiset<int> \n\n{\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n        multiset{x} + Elements(left) + Elements(right)\n}\n\nghost predicate IsBalanced(pq: PQueue) \n\n{\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n        IsBalanced(left) && IsBalanced(right) &&\n        var L, R := |Elements(left)|, |Elements(right)|;\n        L == R || L == R + 1\n}\n\nghost predicate Valid(pq: PQueue) \n\n{\n    IsBinaryHeap(pq) && IsBalanced(pq)\n}\n\npredicate IsEmpty(pq: PQueue) \n\n{\n    pq == Leaf\n}\n\nfunction ReplaceRoot(pq: PQueue, r: int): PQueue\n    requires !IsEmpty(pq)\n\n{\n    // left is empty or r is smaller than either sub-root\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    then\n        // simply replace the root\n        Node(r, pq.left, pq.right)\n    // right is empty, left has one element\n    else if pq.right.Leaf? then\n        Node(pq.left.x, Node(r, Leaf, Leaf), Leaf)\n    // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    else if pq.left.x < pq.right.x then\n        // promote left root\n        Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right)\n    else\n        // promote right root\n        Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r))\n}\n\nghost predicate IsMin(y: int, s: multiset<int>) \n\n{\n    y in s && forall x :: x in s ==> y <= x\n}\n\nKnown Properties:\n\n\nProperty:\nlemma ReplaceRootCorrect(pq: PQueue, r: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, r);\n    Valid(pq') &&\n    r in Elements(pq') &&\n    |Elements(pq')| == |Elements(pq)| &&\n    Elements(pq) + multiset{r} == Elements(pq') + multiset{pq.x}\n\n",
        "output": "{\n    var pq' := ReplaceRoot(pq, r);\n    // Element post-condition\n    var left, right := pq'.left, pq'.right;\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    {\n        // simply replace the root\n        assert Valid(pq');\n        assert |Elements(pq')| == |Elements(pq)|;\n    }\n    else if pq.right.Leaf? {\n        // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    }\n    else if pq.left.x < pq.right.x {\n        // promote left root\n        assert pq.left.Node? && pq.right.Node?;\n        assert pq.left.x < r || pq.right.x < r;\n        assert pq' == Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right);\n        ReplaceRootCorrect(pq.left, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==\n            (multiset{pq.left.x} + Elements(ReplaceRoot(pq.left, r)) + Elements(pq.right)) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.left, r); }\n            (Elements(pq.left) + multiset{r}) + Elements(pq.right) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n    else {\n        // promote right root\n        assert pq' == Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r));\n        ReplaceRootCorrect(pq.right, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==  // defn\n            (multiset{pq.right.x} + Elements(pq.left) + Elements(ReplaceRoot(pq.right, r))) + multiset{pq.x};\n        ==  // assoc\n            (Elements(pq.left) + (Elements(ReplaceRoot(pq.right, r)) + multiset{pq.right.x})) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.right, r); }\n            (Elements(pq.left) + multiset{r} + Elements(pq.right)) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype BraunTree =\n        | Leaf\n        | Node(x: int, left: BraunTree, right: BraunTree)\n\ntype PQueue = BraunTree\n\nghost predicate IsBinaryHeap(pq: PQueue)\n\n{\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n        IsBinaryHeap(left) && IsBinaryHeap(right) &&\n        (left.Leaf? || x <= left.x) &&\n        (right.Leaf? || x <= right.x)\n}\n\nghost function Elements(pq: PQueue): multiset<int> \n\n{\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n        multiset{x} + Elements(left) + Elements(right)\n}\n\nghost predicate IsBalanced(pq: PQueue) \n\n{\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n        IsBalanced(left) && IsBalanced(right) &&\n        var L, R := |Elements(left)|, |Elements(right)|;\n        L == R || L == R + 1\n}\n\nghost predicate Valid(pq: PQueue) \n\n{\n    IsBinaryHeap(pq) && IsBalanced(pq)\n}\n\npredicate IsEmpty(pq: PQueue) \n\n{\n    pq == Leaf\n}\n\nfunction ReplaceRoot(pq: PQueue, r: int): PQueue\n    requires !IsEmpty(pq)\n\n{\n    // left is empty or r is smaller than either sub-root\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    then\n        // simply replace the root\n        Node(r, pq.left, pq.right)\n    // right is empty, left has one element\n    else if pq.right.Leaf? then\n        Node(pq.left.x, Node(r, Leaf, Leaf), Leaf)\n    // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    else if pq.left.x < pq.right.x then\n        // promote left root\n        Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right)\n    else\n        // promote right root\n        Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r))\n}\n\nghost predicate IsMin(y: int, s: multiset<int>) \n\n{\n    y in s && forall x :: x in s ==> y <= x\n}\n\nfunction DeleteMin(pq: PQueue): PQueue\n    requires IsBalanced(pq) && !IsEmpty(pq)\n\n{\n    // Ex. 10.4: by the IsBalanced property, pq.left is always as large or one node larger\n    // than pq.right. Thus pq.left.Leaf? ==> pq.right.leaf?\n    if pq.right.Leaf? then\n        pq.left\n    else if pq.left.x <= pq.right.x then\n        Node(pq.left.x, pq.right, DeleteMin(pq.left))\n    else\n        Node(pq.right.x, ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left))\n}\n\nKnown Properties:\nlemma ReplaceRootCorrect(pq: PQueue, r: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, r);\n    Valid(pq') &&\n    r in Elements(pq') &&\n    |Elements(pq')| == |Elements(pq)| &&\n    Elements(pq) + multiset{r} == Elements(pq') + multiset{pq.x}\n{\n    var pq' := ReplaceRoot(pq, r);\n    // Element post-condition\n    var left, right := pq'.left, pq'.right;\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    {\n        // simply replace the root\n        assert Valid(pq');\n        assert |Elements(pq')| == |Elements(pq)|;\n    }\n    else if pq.right.Leaf? {\n        // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    }\n    else if pq.left.x < pq.right.x {\n        // promote left root\n        assert pq.left.Node? && pq.right.Node?;\n        assert pq.left.x < r || pq.right.x < r;\n        assert pq' == Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right);\n        ReplaceRootCorrect(pq.left, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==\n            (multiset{pq.left.x} + Elements(ReplaceRoot(pq.left, r)) + Elements(pq.right)) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.left, r); }\n            (Elements(pq.left) + multiset{r}) + Elements(pq.right) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n    else {\n        // promote right root\n        assert pq' == Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r));\n        ReplaceRootCorrect(pq.right, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==  // defn\n            (multiset{pq.right.x} + Elements(pq.left) + Elements(ReplaceRoot(pq.right, r))) + multiset{pq.x};\n        ==  // assoc\n            (Elements(pq.left) + (Elements(ReplaceRoot(pq.right, r)) + multiset{pq.right.x})) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.right, r); }\n            (Elements(pq.left) + multiset{r} + Elements(pq.right)) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n}\n\nlemma BinaryHeapStoresMin(pq: PQueue, y: int)\n    requires IsBinaryHeap(pq) && y in Elements(pq)\n    ensures pq.x <= y\n{}\n\n\n\nProperty:\nlemma {:isolate_assertions}DeleteMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := DeleteMin(pq);\n    Valid(pq') &&\n    Elements(pq') + multiset{pq.x} == Elements(pq) &&\n    |Elements(pq')| == |Elements(pq)| - 1 \n\n",
        "output": "{\n    if pq.left.Leaf? || pq.right.Leaf? {}\n    else if pq.left.x <= pq.right.x {\n        DeleteMinCorrect(pq.left);\n    } else {\n        var left, right := ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left);\n        var pq' := Node(pq.right.x, left, right);\n        assert pq' == DeleteMin(pq);\n        \n        // Elements post-condition\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==  // defn Elements\n            (multiset{pq.right.x} + Elements(left) + Elements(right)) + multiset{pq.x};\n        ==  // multiset left assoc\n            ((multiset{pq.right.x} + Elements(left)) + Elements(right)) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.right, pq.left.x);\n                assert multiset{pq.right.x} + Elements(left) == Elements(pq.right) + multiset{pq.left.x}; }\n            ((Elements(pq.right) + multiset{pq.left.x}) + Elements(right)) + multiset{pq.x};\n        ==  // defn right\n            ((Elements(pq.right) + multiset{pq.left.x}) + Elements(DeleteMin(pq.left))) + multiset{pq.x};\n        ==  // multiset right assoc\n            (Elements(pq.right) + (multiset{pq.left.x} + Elements(DeleteMin(pq.left)))) + multiset{pq.x};\n        == { DeleteMinCorrect(pq.left);\n                assert multiset{pq.left.x} + Elements(DeleteMin(pq.left)) == Elements(pq.left); }\n            (Elements(pq.right) + (Elements(pq.left))) + multiset{pq.x};\n        ==\n            multiset{pq.x} + Elements(pq.right) + (Elements(pq.left));\n        ==\n            Elements(pq);\n        }\n        \n        // Validity\n        // Prove IsBinaryHeap(pq')\n        // IsBinaryHeap(left) && IsBinaryHeap(right) &&\n        DeleteMinCorrect(pq.left);\n        assert Valid(right);\n        ReplaceRootCorrect(pq.right, pq.left.x);\n        assert Valid(left);\n        \n        // (left.Leaf? || x <= left.x) &&\n        assert pq.left.x in Elements(left);\n        assert pq.right.x <= pq.left.x;\n        BinaryHeapStoresMin(pq.left, pq.left.x);\n        BinaryHeapStoresMin(pq.right, pq.right.x);\n        // assert pq.right.x <= left.x;\n        // (right.Leaf? || x <= right.x)\n        assert right.Leaf? || pq.right.x <= right.x;\n        assert IsBinaryHeap(pq');\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype BraunTree =\n        | Leaf\n        | Node(x: int, left: BraunTree, right: BraunTree)\n\ntype PQueue = BraunTree\n\nghost predicate IsBinaryHeap(pq: PQueue)\n\n{\n    match pq\n    case Leaf => true\n    case Node(x, left, right) =>\n        IsBinaryHeap(left) && IsBinaryHeap(right) &&\n        (left.Leaf? || x <= left.x) &&\n        (right.Leaf? || x <= right.x)\n}\n\nghost function Elements(pq: PQueue): multiset<int> \n\n{\n    match pq\n    case Leaf => multiset{}\n    case Node(x, left, right) =>\n        multiset{x} + Elements(left) + Elements(right)\n}\n\nghost predicate IsBalanced(pq: PQueue) \n\n{\n    match pq\n    case Leaf => true\n    case Node(_, left, right) =>\n        IsBalanced(left) && IsBalanced(right) &&\n        var L, R := |Elements(left)|, |Elements(right)|;\n        L == R || L == R + 1\n}\n\nghost predicate Valid(pq: PQueue) \n\n{\n    IsBinaryHeap(pq) && IsBalanced(pq)\n}\n\npredicate IsEmpty(pq: PQueue) \n\n{\n    pq == Leaf\n}\n\nfunction ReplaceRoot(pq: PQueue, r: int): PQueue\n    requires !IsEmpty(pq)\n\n{\n    // left is empty or r is smaller than either sub-root\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    then\n        // simply replace the root\n        Node(r, pq.left, pq.right)\n    // right is empty, left has one element\n    else if pq.right.Leaf? then\n        Node(pq.left.x, Node(r, Leaf, Leaf), Leaf)\n    // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    else if pq.left.x < pq.right.x then\n        // promote left root\n        Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right)\n    else\n        // promote right root\n        Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r))\n}\n\nghost predicate IsMin(y: int, s: multiset<int>) \n\n{\n    y in s && forall x :: x in s ==> y <= x\n}\n\nfunction DeleteMin(pq: PQueue): PQueue\n    requires IsBalanced(pq) && !IsEmpty(pq)\n\n{\n    // Ex. 10.4: by the IsBalanced property, pq.left is always as large or one node larger\n    // than pq.right. Thus pq.left.Leaf? ==> pq.right.leaf?\n    if pq.right.Leaf? then\n        pq.left\n    else if pq.left.x <= pq.right.x then\n        Node(pq.left.x, pq.right, DeleteMin(pq.left))\n    else\n        Node(pq.right.x, ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left))\n}\n\nfunction RemoveMin(pq: PQueue): (int, PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n\n{\n    var Node(x, left, right) := pq;\n    (x, DeleteMin(pq))\n}\n\nKnown Properties:\nlemma ReplaceRootCorrect(pq: PQueue, r: int)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := ReplaceRoot(pq, r);\n    Valid(pq') &&\n    r in Elements(pq') &&\n    |Elements(pq')| == |Elements(pq)| &&\n    Elements(pq) + multiset{r} == Elements(pq') + multiset{pq.x}\n{\n    var pq' := ReplaceRoot(pq, r);\n    // Element post-condition\n    var left, right := pq'.left, pq'.right;\n    if pq.left.Leaf? ||\n        (r <= pq.left.x && (pq.right.Leaf? || r <= pq.right.x))\n    {\n        // simply replace the root\n        assert Valid(pq');\n        assert |Elements(pq')| == |Elements(pq)|;\n    }\n    else if pq.right.Leaf? {\n        // both left/right are non-empty and `r` needs to be inserted deeper in the sub-trees\n    }\n    else if pq.left.x < pq.right.x {\n        // promote left root\n        assert pq.left.Node? && pq.right.Node?;\n        assert pq.left.x < r || pq.right.x < r;\n        assert pq' == Node(pq.left.x, ReplaceRoot(pq.left, r), pq.right);\n        ReplaceRootCorrect(pq.left, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==\n            (multiset{pq.left.x} + Elements(ReplaceRoot(pq.left, r)) + Elements(pq.right)) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.left, r); }\n            (Elements(pq.left) + multiset{r}) + Elements(pq.right) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n    else {\n        // promote right root\n        assert pq' == Node(pq.right.x, pq.left, ReplaceRoot(pq.right, r));\n        ReplaceRootCorrect(pq.right, r);\n        assert Valid(pq');\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==  // defn\n            (multiset{pq.right.x} + Elements(pq.left) + Elements(ReplaceRoot(pq.right, r))) + multiset{pq.x};\n        ==  // assoc\n            (Elements(pq.left) + (Elements(ReplaceRoot(pq.right, r)) + multiset{pq.right.x})) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.right, r); }\n            (Elements(pq.left) + multiset{r} + Elements(pq.right)) + multiset{pq.x};\n        ==\n            Elements(pq) + multiset{r};\n        }\n    }\n}\n\nlemma BinaryHeapStoresMin(pq: PQueue, y: int)\n    requires IsBinaryHeap(pq) && y in Elements(pq)\n    ensures pq.x <= y\n{}\n\nlemma {:isolate_assertions}DeleteMinCorrect(pq: PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n    ensures var pq' := DeleteMin(pq);\n    Valid(pq') &&\n    Elements(pq') + multiset{pq.x} == Elements(pq) &&\n    |Elements(pq')| == |Elements(pq)| - 1\n{\n    if pq.left.Leaf? || pq.right.Leaf? {}\n    else if pq.left.x <= pq.right.x {\n        DeleteMinCorrect(pq.left);\n    } else {\n        var left, right := ReplaceRoot(pq.right, pq.left.x), DeleteMin(pq.left);\n        var pq' := Node(pq.right.x, left, right);\n        assert pq' == DeleteMin(pq);\n        \n        // Elements post-condition\n        calc {\n            Elements(pq') + multiset{pq.x};\n        ==  // defn Elements\n            (multiset{pq.right.x} + Elements(left) + Elements(right)) + multiset{pq.x};\n        ==  // multiset left assoc\n            ((multiset{pq.right.x} + Elements(left)) + Elements(right)) + multiset{pq.x};\n        == { ReplaceRootCorrect(pq.right, pq.left.x);\n                assert multiset{pq.right.x} + Elements(left) == Elements(pq.right) + multiset{pq.left.x}; }\n            ((Elements(pq.right) + multiset{pq.left.x}) + Elements(right)) + multiset{pq.x};\n        ==  // defn right\n            ((Elements(pq.right) + multiset{pq.left.x}) + Elements(DeleteMin(pq.left))) + multiset{pq.x};\n        ==  // multiset right assoc\n            (Elements(pq.right) + (multiset{pq.left.x} + Elements(DeleteMin(pq.left)))) + multiset{pq.x};\n        == { DeleteMinCorrect(pq.left);\n                assert multiset{pq.left.x} + Elements(DeleteMin(pq.left)) == Elements(pq.left); }\n            (Elements(pq.right) + (Elements(pq.left))) + multiset{pq.x};\n        ==\n            multiset{pq.x} + Elements(pq.right) + (Elements(pq.left));\n        ==\n            Elements(pq);\n        }\n        \n        // Validity\n        // Prove IsBinaryHeap(pq')\n        // IsBinaryHeap(left) && IsBinaryHeap(right) &&\n        DeleteMinCorrect(pq.left);\n        assert Valid(right);\n        ReplaceRootCorrect(pq.right, pq.left.x);\n        assert Valid(left);\n        \n        // (left.Leaf? || x <= left.x) &&\n        assert pq.left.x in Elements(left);\n        assert pq.right.x <= pq.left.x;\n        BinaryHeapStoresMin(pq.left, pq.left.x);\n        BinaryHeapStoresMin(pq.right, pq.right.x);\n        // assert pq.right.x <= left.x;\n        // (right.Leaf? || x <= right.x)\n        assert right.Leaf? || pq.right.x <= right.x;\n        assert IsBinaryHeap(pq');\n    }\n}\n\nfunction RemoveMin(pq: PQueue): (int, PQueue)\n    requires Valid(pq) && !IsEmpty(pq)\n{\n    var Node(x, left, right) := pq;\n    (x, DeleteMin(pq))\n}\n\n\n\nProperty:\nlemma RemoveMinCorrect(pq: PQueue)\n    requires Valid(pq)\n    requires !IsEmpty(pq)\n    ensures var (y, pq') := RemoveMin(pq);\n            Elements(pq) == Elements(pq') + multiset\n\n",
        "output": " {\n    DeleteMinCorrect(pq);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction Power10(n: nat): (r: nat)\n    ensures r >= 1\n    ensures n > 0 ==> r % 10 == 0\n\n{\n\tif (n == 0) then 1 else 10 * Power10(n-1)\n}\n\nfunction NumberOfDigits(n: nat) : (r: nat)\n    ensures r >= 1\n    ensures r == 1 <==> 0 <= n <= 9\n\n{\n    if 0 <= n <= 9 then 1 else 1+NumberOfDigits(n/10)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma NumberIdentity(number: nat, pmax: nat)\n    requires pmax == Power10(NumberOfDigits(number))\n    ensures number == number % pmax\n\n\n",
        "output": "{\n    if NumberOfDigits(number) == 1\n    {\n        assert 0 <= number <= 9; \n        assert pmax == 10;\n        assert number == number % pmax;\n    }\n    else // > 1\n    {\n        assert pmax == Power10(NumberOfDigits(number)) ==> pmax/10 == Power10(NumberOfDigits(number/10));\n        NumberIdentity(number/10, pmax/10);\n        assert number >= 10;\n        assert pmax >= 100;\n        assert number < pmax;\n        assert forall n, m :: 0 < n < m <= pmax ==> n%m == n;\n        assert number == number % pmax;\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction sum(s : seq<nat>) : nat\n    ensures sum(s) == 0 ==> forall i :: 0 <= i < |s| ==> s[i] == 0\n\n{\n    if s == [] then 0 else s[0] + sum(s[1..])\n}\n\nKnown Properties:\nlemma sum_eq(s1 : seq<nat>, s2 : seq<nat>)\n    requires |s1| == |s2|\n    requires forall i :: 0 <= i < |s1| ==> s1[i] == s2[i]\n    ensures sum(s1) == sum(s2)\n\n{}\n\n\n\nProperty:\nlemma sum_exept(s1 : seq<nat>, s2 : seq<nat>, x : nat, j : nat)\n    requires |s1| == |s2|\n    requires j < |s1|\n    requires forall i :: 0 <= i < |s1| ==> i != j ==> s1[i] == s2[i]\n    requires s1[j] == s2[j] + x\n    ensures sum(s1) == sum(s2) + x\n\n\n",
        "output": "{\n    if s1 == [] {\n        assert(j >= |s1|);\n    } else {\n        if j == 0 {\n            assert (sum(s1) == s1[0] + sum(s1[1..]));\n            assert (sum(s2) == s2[0] + sum(s2[1..]));\n            sum_eq(s1[1..], s2[1..]);\n            assert sum(s1[1..]) == sum(s2[1..]);\n        } else {\n            sum_exept(s1[1..], s2[1..], x, j - 1);\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SetRange(n: int) : set<int>\n\n{\n    set i | 0 <= i < n\n}\n\nKnown Properties:\n\n\nProperty:\nlemma CardinalitySetRange(n: int)\n    requires n >= 0\n    ensures |SetRange(n)| == n\n\n\n",
        "output": "{\n    if n == 0 {\n    } else {\n        CardinalitySetRange(n-1);\n        assert SetRange(n)\n            == SetRange(n-1) + {n-1};\n    }\n}\n\n"
    }
]