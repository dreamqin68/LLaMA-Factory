[
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursiveCount(key: int, q: seq<int>): int\n\tdecreases |q|\n\n{\n\tif q == [] then 0\n\telse if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])\n\telse RecursiveCount(key, q[..|q|-1])\n}\n\nfunction county(elem: int, key: int): int\n\n{\n\tif elem==key then 1 else 0\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Lemma_Count_Inv(q: seq<int>, i: nat, count: int, key: int)\n\trequires 0 <= i < |q| && count == RecursiveCount(key, q[..i])\n\tensures 0 <= i+1 <= |q| && county(q[i],key)+count == RecursiveCount(key, q[..i+1])\n\n\n",
        "output": "{\n\tassert q[..i+1] == q[..i] + [q[i]];\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursivePositiveProduct(q: seq<int>): int\n\tdecreases |q|\n\n{\n\tif q == [] then 1\n\telse if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n\telse q[0] * RecursivePositiveProduct(q[1..])\n}\n\nfunction prody(elem: int): int \n\n{\n\tif elem <= 0 then 1 else elem\n}\n\nKnown Properties:\n\n\nProperty:\nlemma AppendProd(q: seq<int>)\n\trequires q != [] \n\tensures RecursivePositiveProduct(q) == RecursivePositiveProduct(q[..|q|-1])*prody(q[|q|-1])\t\n\n\n",
        "output": "{\n\tif |q| == 1\n\t{\n\t\tassert RecursivePositiveProduct(q) == prody(q[0]);\n\t}\n\telse\n\t{\t\t\n        // inductive step\n\t\tvar q1 := q[1..];\n\t\tcalc {\n\t\t\tRecursivePositiveProduct(q);\n\t\t== // def. for a non-empty sequence\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q[1..]);\n\t\t== { assert q1 != []; assert |q1| < |q|; AppendProd(q1); } // induction hypothesis (one assertion for the precondition, another for termination)\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q1[..|q1|-1]) * prody(q1[|q1|-1]);\n\t\t== { assert q1[..|q1|-1] == q[1..|q|-1]; assert q1[|q1|-1] == q[|q|-1]; }\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q[1..|q|-1])  * prody(q[|q|-1]);\n\t\t== \n\t\t\tRecursivePositiveProduct(q[..|q|-1])  * prody(q[|q|-1]);\n\t\t}\n\t}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursivePositiveProduct(q: seq<int>): int\n\tdecreases |q|\n\n{\n\tif q == [] then 1\n\telse if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n\telse q[0] * RecursivePositiveProduct(q[1..])\n}\n\nfunction prody(elem: int): int \n\n{\n\tif elem <= 0 then 1 else elem\n}\n\nKnown Properties:\nlemma AppendProd(q: seq<int>)\n\trequires q != [] \n\tensures RecursivePositiveProduct(q) == RecursivePositiveProduct(q[..|q|-1])*prody(q[|q|-1])\t\n\n{\n\tif |q| == 1\n\t{\n\t\tassert RecursivePositiveProduct(q) == prody(q[0]);\n\t}\n\telse\n\t{\t\t\n        // inductive step\n\t\tvar q1 := q[1..];\n\t\tcalc {\n\t\t\tRecursivePositiveProduct(q);\n\t\t== // def. for a non-empty sequence\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q[1..]);\n\t\t== { assert q1 != []; assert |q1| < |q|; AppendProd(q1); } // induction hypothesis (one assertion for the precondition, another for termination)\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q1[..|q1|-1]) * prody(q1[|q1|-1]);\n\t\t== { assert q1[..|q1|-1] == q[1..|q|-1]; assert q1[|q1|-1] == q[|q|-1]; }\n\t\t\tprody(q[0]) * RecursivePositiveProduct(q[1..|q|-1])  * prody(q[|q|-1]);\n\t\t== \n\t\t\tRecursivePositiveProduct(q[..|q|-1])  * prody(q[|q|-1]);\n\t\t}\n\t}\n}\n\n\n\nProperty:\nlemma Lemma_Prod_Inv(q: seq<int>, i: nat, prod: int)\n\trequires 0 <= i < |q| && prod == RecursivePositiveProduct(q[..i])\n\tensures 0 <= i+1 <= |q| && prody(q[i])*prod == RecursivePositiveProduct(q[..i+1])\n\n\n",
        "output": "{\n\tassert q[..i+1] == q[..i] + [q[i]];\n\tvar q1 := q[..i+1];\n\tcalc {\n\t\tRecursivePositiveProduct(q[..i+1]);\n\t== // def.\n\t\tif q1 == [] then 1\n\t\telse if q1[0] <= 0 then RecursivePositiveProduct(q1[1..])\n\t\telse q1[0] * RecursivePositiveProduct(q1[1..]);\n\t== { assert q1 != []; } // simplification for a non-empty sequence\n\t\tif q1[0] <= 0 then RecursivePositiveProduct(q1[1..])\n\t\telse q1[0] * RecursivePositiveProduct(q1[1..]);\n\t== // def. of q1\n\t\tif q[0] <= 0 then RecursivePositiveProduct(q[1..i+1])\n\t\telse q[0] * RecursivePositiveProduct(q[1..i+1]);\n\t== \n\t\t(if q[0] <= 0 then 1 else q[0])*RecursivePositiveProduct(q[1..i+1]);\n\t==\n\t\tprody(q[0])*RecursivePositiveProduct(q[1..i+1]);\n\t== \n\t\tRecursivePositiveProduct(q[..i+1]);\n\t== {AppendProd(q[..i+1]);}\n\t\tprody(q[i])*RecursivePositiveProduct(q[..i]);\n\t==\n\t\tprody(q[i])*prod;\n\t}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursiveCount(key: int, q: seq<int>): int\n\tdecreases |q|\n\n{\n\tif q == [] then 0\n\telse if q[|q|-1] == key then 1+RecursiveCount(key, q[..|q|-1])\n\telse RecursiveCount(key, q[..|q|-1])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Lemma_Count_Finish(q: seq<int>, i: nat, count: int, key: int)\n\trequires inv: 0 <= i <= |q| && count == RecursiveCount(key, q[..i])\n\trequires neg_of_guard: i >= |q|\n\tensures count == RecursiveCount(key, q)\n\n\n",
        "output": "{\n\tassert i <= |q| && count == RecursiveCount(key, q[..i]) by { reveal inv; }\n\tassert i == |q| by { reveal inv,neg_of_guard; }\n\tassert q[..i] == q[..|q|] == q;\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursivePositiveProduct(q: seq<int>): int\n\tdecreases |q|\n\n{\n\tif q == [] then 1\n\telse if q[0] <= 0 then RecursivePositiveProduct(q[1..])\n\telse q[0] * RecursivePositiveProduct(q[1..])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Lemma_Prod_Finish(q: seq<int>, i: nat, prod: int)\n\trequires inv: 0 <= i <= |q| && prod == RecursivePositiveProduct(q[..i])\n\trequires neg_of_guard: i >= |q|\n\tensures prod == RecursivePositiveProduct(q)\n\n\n",
        "output": "{\n\tassert i <= |q| && prod == RecursivePositiveProduct(q[..i]) by { reveal inv; }\n\tassert i == |q| by { reveal inv,neg_of_guard; }\n\tassert q[..i] == q[..|q|] == q;\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Unary = Zero | Suc(pred: Unary)\n\npredicate Less(x: Unary, y: Unary) \n\n{\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\nfunction Add(x: Unary, y: Unary): Unary \n\n{\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nKnown Properties:\n\n\nProperty:\nlemma AddCommutative(a: Unary, b: Unary)\n  ensures Add(a, b) == Add(b, a)\n\n\n",
        "output": "{\n  match b\n  case Zero => \n    calc{\n      Add(a, b);\n      ==\n      Add(a, Zero);\n      == // def. Add\n      a;\n      == \n      Add(Zero, a);\n      ==\n      Add(b, a);\n    }\n  case Suc(b') =>\n    calc{\n      Add(a, b);\n      ==\n      Add(a, Suc(b'));\n      == // def. Add\n      Suc(Add(a, b'));\n      == {AddCommutative(a, b');\n          assert Add(a, b') == Add(b', a);}\n      Suc(Add(b', a));\n      == \n      Add(Suc(b'), a);\n      ==\n      Add(b, a);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Unary = Zero | Suc(pred: Unary)\n\npredicate Less(x: Unary, y: Unary) \n\n{\n  y != Zero && (x.Suc? ==> Less(x.pred, y.pred))\n}\n\nfunction Add(x: Unary, y: Unary): Unary \n\n{\n  match y\n  case Zero => x\n  case Suc(y') => Suc(Add(x, y'))\n}\n\nfunction Mul(x: Unary, y: Unary): Unary \n\n{\n  match x\n  case Zero => Zero\n  case Suc(x') => Add(Mul(x', y), y)\n}\n\nfunction Sub(x: Unary, y: Unary): Unary\n  requires !Less(x, y)\n\n{\n  match y\n  case Zero => x\n  case Suc(y') => Sub(x.pred, y')\n}\n\nKnown Properties:\nlemma AddTransitive(a: Unary, b: Unary, c: Unary)\n  ensures Add(a, Add(b, c)) == Add(Add(a, b), c)\n\n{}\n\nlemma AddSub(x: Unary, y: Unary)\n  requires !Less(x, y)\n  ensures Add(Sub(x, y), y) == x\n\n{}\n\nlemma AddCommutative(a: Unary, b: Unary)\n  ensures Add(a, b) == Add(b, a)\n\n{\n  match b\n  case Zero => \n    calc{\n      Add(a, b);\n      ==\n      Add(a, Zero);\n      == // def. Add\n      a;\n      == \n      Add(Zero, a);\n      ==\n      Add(b, a);\n    }\n  case Suc(b') =>\n    calc{\n      Add(a, b);\n      ==\n      Add(a, Suc(b'));\n      == // def. Add\n      Suc(Add(a, b'));\n      == {AddCommutative(a, b');\n          assert Add(a, b') == Add(b', a);}\n      Suc(Add(b', a));\n      == \n      Add(Suc(b'), a);\n      ==\n      Add(b, a);\n    }\n}\n\n\n\nProperty:\nlemma AddMulSucSubEqAddMul(d: Unary, y: Unary, x0: Unary)\n  requires !Less(x0, y)\n  requires y != Zero\n  ensures Add(Mul(Suc(d), y), Sub(x0, y)) == Add(Mul(d, y), x0)\n\n\n",
        "output": "{\n  calc{\n    Add(Mul(Suc(d), y), Sub(x0, y));\n    == \n    Add(Add(Mul(d, y), y), Sub(x0, y));\n    == \n\t{AddTransitive(Mul(d, y), y, Sub(x0, y));\n        assert Add(Mul(d, y), Add(y, Sub(x0, y))) == Add(Add(Mul(d, y), y), Sub(x0, y));}\n    Add(Mul(d, y), Add(y, Sub(x0, y)));\n    == \n\t  {AddCommutative(Sub(x0, y), y);\n        assert Add(Sub(x0, y), y) == Add(y, Sub(x0, y));}\n    Add(Mul(d, y), Add(Sub(x0, y), y));\n    == {assert !Less(x0, y);\n        AddSub(x0, y);\n        assert Add(Sub(x0, y), y) == x0;}\n    Add(Mul(d, y), x0);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction count(a: seq<bool>): nat\n\n{\n  if |a| == 0 then 0 else\n    (if a[0] then 1 else 0) + count(a[1..])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures count(a + b) == count(a) + count(b)\n\n\n",
        "output": "{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    DistributiveLemma(a[1..], b);\n    assert a + b == [a[0]] + (a[1..] + b);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction fact(n:nat): nat\n decreases n\n\n{\n    if n == 0 then 1 else n * fact(n-1)\n}\n\nfunction factAcc(n:nat, a:int): int\n decreases n\n\n{\n    if (n==0) then a else factAcc(n-1,n*a)\n}\n\nfunction factAlt(n:nat):int\n\n{\n    factAcc(n,1)\n}\n\nKnown Properties:\nlemma factAcc_correct(n:nat, a:int)\n ensures factAcc(n, a) == a*fact(n)\n\n{}\n\n\n\nProperty:\nlemma factAlt_correct(n:nat)\n    ensures factAlt(n) == fact(n)\n\n\n",
        "output": "{\n    factAcc_correct(n,1);\n    assert factAcc(n,1) == 1 * fact(n);\n    assert 1 * fact(n) == fact(n);\n    assert factAlt(n) == factAcc(n, 1);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nfunction length<T> (l: List<T>) : nat\n    decreases l\n\n{\n    match l\n    case Nil => 0\n    case Cons(_, r) => 1 + length(r)\n}\n\nfunction lengthTL<T> (l: List<T>, acc: nat) : nat\n\n{\n    match l\n    case Nil => acc\n    case Cons(_, r) => lengthTL(r, 1 + acc)\n}\n\nKnown Properties:\nlemma lengthTL_aux<T> (l: List<T>, acc: nat)\n    ensures lengthTL(l, acc) == acc + length(l)\n\n{}\n\n\n\nProperty:\nlemma lengthEq<T> (l: List<T>)\n    ensures length(l) == lengthTL(l,0)\n\n\n",
        "output": "{\n    lengthTL_aux(l, 0);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n\n{\n    if a < b then a else ModSub(a - b, b)\n}\n\nKnown Properties:\nlemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n\n{\n    var c := (a - b) / b - (a / b) + 1;\n    assert c * b + (a - b) % b - a % b == 0;\n}\n\n\n\nProperty:\nlemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n\n\n",
        "output": "{\n    if a >= b {\n        DivModSub1(a, b);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n\n{\n    if a < b then 0 else 1 + DivSub(a - b, b)\n}\n\nKnown Properties:\nlemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n\n{\n    var c := (a - b) / b - (a / b) + 1;\n    assert c * b + (a - b) % b - a % b == 0;\n}\n\n\n\nProperty:\nlemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n\n\n",
        "output": "{\n    if a >= b {\n        DivModSub1(a, b);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n\n{\n    if a < b then a else ModSub(a - b, b)\n}\n\nfunction DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n\n{\n    if a < b then 0 else 1 + DivSub(a - b, b)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n\n\n",
        "output": "{\n    if q > 0 {\n        DivModSpec'(a - b, b, q - 1, r);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype INodePort = inodeport(node_id: nat, port_id: nat)\ndatatype ONodePort = onodeport(node_id: nat, port_id: nat)\n\nfunction UpdateMap<T(!new), U>(A: map<T, U>, f: T->T, g: U->U): (result: map<T, U>)\n    requires forall x: T, y: T :: x != y ==> f(x) != f(y)\n    ensures forall x :: x in A <==> f(x) in result\n    ensures forall x :: x in A ==> g(A[x]) == result[f(x)]\n\n{\n    map x | x in A :: f(x) := g(A[x])\n}\n\nfunction CombineMaps<T(!new), U>(a: map<T, U>, b: map<T, U>): map<T, U>\n    requires forall x :: x in a ==> x !in b\n    requires forall x :: x in b ==> x !in a\n    ensures\n        var result := CombineMaps(a, b);\n        (forall x :: x in a ==> a[x] == result[x]) &&\n        (forall x :: x in b ==> b[x] == result[x]) &&\n        (forall x :: x in result ==> (x in a) || (x in b))\n\n{\n    map x | x in (a.Keys + b.Keys) :: if x in a then a[x] else b[x]\n}\n\nfunction CombineBackconns(\n    offset: nat,\n    bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>): (result: map<INodePort, ONodePort>)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n\n{\n    var f:= (inp: INodePort) => inodeport(inp.node_id + offset, inp.port_id);\n    var g := (onp: ONodePort) => onodeport(onp.node_id + offset, onp.port_id);\n    var backconns2 := UpdateMap(bc2, f, g);\n    CombineMaps(bc1, backconns2)\n}\n\nKnown Properties:\nlemma CombineBackconnsHelper(\n        offset: nat,\n        bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>, result: map<INodePort, ONodePort>)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n    requires result == CombineBackconns(offset, bc1, bc2)\n    ensures forall inp :: inp in bc1 ==> (\n            inp in result &&\n            result[inp] == bc1[inp])\n    ensures forall inp :: inp in bc2 ==> (\n            inodeport(inp.node_id+offset, inp.port_id) in result &&\n            result[inodeport(inp.node_id+offset, inp.port_id)] == onodeport(bc2[inp].node_id+offset, bc2[inp].port_id))\n\n{}\n\n\n\nProperty:\nlemma CombineBackconnsHelper2(\n        offset: nat,\n        bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>, result: map<INodePort, ONodePort>, inp: INodePort)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n    requires result == CombineBackconns(offset, bc1, bc2)\n    requires inp in bc2\n    ensures inodeport(inp.node_id+offset, inp.port_id) in result\n    ensures result[inodeport(inp.node_id+offset, inp.port_id)] == onodeport(bc2[inp].node_id+offset, bc2[inp].port_id)\n\n\n",
        "output": "{\n    CombineBackconnsHelper(offset, bc1, bc2, result);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype INodePort = inodeport(node_id: nat, port_id: nat)\ndatatype ONodePort = onodeport(node_id: nat, port_id: nat)\n\n// Currently the nodes can just be Xor, And or Identity gates.\ndatatype Node =\n    Xor |\n    And |\n    Ident\n\n// A circuit is represented by the nodes and the connections between the nodes.\n// Each output port can go to many input ports.\n// But each input port can only be connected to one output port.\ndatatype Circuit = Circ(\n    nodes: seq<Node>,\n    backconns: map<INodePort, ONodePort>\n    )\n\n// The number of input ports for each kind of node.\nfunction n_iports (node: Node): nat\n\n{\n    match node {\n        case Xor => 2\n        case And => 2\n        case Ident => 1\n    } \n}\n\nfunction n_oports (node: Node): nat\n\n{\n    match node {\n        case Xor => 1\n        case And => 1\n        case Ident => 1\n    } \n}\n\npredicate WellformedINP(c: Circuit, inp: INodePort)\n\n{\n    (0 <= inp.node_id < |c.nodes|) && (inp.port_id < n_iports(c.nodes[inp.node_id]))\n}\n\npredicate WellformedONP(c: Circuit, onp: ONodePort)\n\n{\n    (0 <= onp.node_id < |c.nodes|) && (onp.port_id < n_oports(c.nodes[onp.node_id]))\n}\n\npredicate WellformedBackConns(c: Circuit)\n\n{\n    forall inp :: inp in c.backconns ==>\n        WellformedINP(c, inp) &&\n        WellformedONP(c, c.backconns[inp])\n}\n\nghost predicate Wellformed(c: Circuit)\n\n{\n    WellformedBackConns(c)\n}\n\nfunction UpdateMap<T(!new), U>(A: map<T, U>, f: T->T, g: U->U): (result: map<T, U>)\n    requires forall x: T, y: T :: x != y ==> f(x) != f(y)\n    ensures forall x :: x in A <==> f(x) in result\n    ensures forall x :: x in A ==> g(A[x]) == result[f(x)]\n\n{\n    map x | x in A :: f(x) := g(A[x])\n}\n\nfunction CombineMaps<T(!new), U>(a: map<T, U>, b: map<T, U>): map<T, U>\n    requires forall x :: x in a ==> x !in b\n    requires forall x :: x in b ==> x !in a\n    ensures\n        var result := CombineMaps(a, b);\n        (forall x :: x in a ==> a[x] == result[x]) &&\n        (forall x :: x in b ==> b[x] == result[x]) &&\n        (forall x :: x in result ==> (x in a) || (x in b))\n\n{\n    map x | x in (a.Keys + b.Keys) :: if x in a then a[x] else b[x]\n}\n\nfunction CombineBackconns(\n        offset: nat,\n        bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>): (result: map<INodePort, ONodePort>)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n\n{\n    var f:= (inp: INodePort) => inodeport(inp.node_id + offset, inp.port_id);\n    var g := (onp: ONodePort) => onodeport(onp.node_id + offset, onp.port_id);\n    var backconns2 := UpdateMap(bc2, f, g);\n    CombineMaps(bc1, backconns2)\n}\n\nfunction CombineCircuits(c1: Circuit, c2: Circuit): (r: Circuit)\n    requires Wellformed(c1)\n    requires Wellformed(c2)\n\n{\n    var new_nodes := c1.nodes + c2.nodes;\n    var new_backconns := CombineBackconns(\n        |c1.nodes|, c1.backconns, c2.backconns);\n    Circ(new_nodes, new_backconns)\n}\n\npredicate IsEquivalentCircuit(node_is_member: nat->bool, node_map: nat-->nat, c1: Circuit, c2: Circuit)\n    requires forall inp :: inp in c1.backconns && node_is_member(inp.node_id) ==> node_is_member(c1.backconns[inp].node_id)\n    requires forall n :: node_is_member(n) ==> node_map.requires(n)\n\n{\n    forall inp :: inp in c1.backconns && node_is_member(inp.node_id) ==>\n        inodeport(node_map(inp.node_id), inp.port_id) in c2.backconns &&\n        var inp2 := inodeport(node_map(inp.node_id), inp.port_id);\n        var onp := c1.backconns[inp];\n        onodeport(node_map(onp.node_id), onp.port_id) == c2.backconns[inp2]\n}\n\nfunction definition.\n        forall inp :: inp in c2.backconns && node_is_member(inp.node_id) ==>\n            inodeport(node_map(inp.node_id), inp.port_id) in r.backconns &&\n            var inp2 := inodeport(node_map(inp.node_id), inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(node_map(onp.node_id), onp.port_id) == r.backconns[inp2];\n        // Substitute in the node_is_member and node_is_map definiions.\n        // For some reason this cause the solver to take too long.\n        forall inp :: inp in c2.backconns ==>\n            inodeport(inp.node_id+offset, inp.port_id) in r.backconns &&\n            var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(onp.node_id+offset, onp.port_id) == r.backconns[inp2];\n    }\n    assert basic_result: r.backconns == CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns)\n        by \n{\n            reveal r_is_result;\n        }\n\nKnown Properties:\nlemma CombineBackconnsHelper(\n        offset: nat,\n        bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>, result: map<INodePort, ONodePort>)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n    requires result == CombineBackconns(offset, bc1, bc2)\n    ensures forall inp :: inp in bc1 ==> (\n            inp in result &&\n            result[inp] == bc1[inp])\n    ensures forall inp :: inp in bc2 ==> (\n            inodeport(inp.node_id+offset, inp.port_id) in result &&\n            result[inodeport(inp.node_id+offset, inp.port_id)] == onodeport(bc2[inp].node_id+offset, bc2[inp].port_id))\n\n{}\n\nlemma CombineBackconnsHelper2(\n        offset: nat,\n        bc1: map<INodePort, ONodePort>, bc2: map<INodePort, ONodePort>, result: map<INodePort, ONodePort>, inp: INodePort)\n    requires forall inp :: inp in bc1 ==> inp.node_id < offset\n    requires result == CombineBackconns(offset, bc1, bc2)\n    requires inp in bc2\n    ensures inodeport(inp.node_id+offset, inp.port_id) in result\n    ensures result[inodeport(inp.node_id+offset, inp.port_id)] == onodeport(bc2[inp].node_id+offset, bc2[inp].port_id)\n\n{\n    CombineBackconnsHelper(offset, bc1, bc2, result);\n}\n\n\n\nProperty:\nlemma CombineCircuitsCorrect(c1: Circuit, c2: Circuit, r: Circuit)\n    requires Wellformed(c1)\n    requires Wellformed(c2)\n    requires r_is_result: r == CombineCircuits(c1, c2)\n    ensures\n        var offset := |c1.nodes|;\n        // The original c1 has an image in r.\n        IsEquivalentCircuit(a=>true, a=>a, c1, r) &&\n        // This subset of r has an image in c1.\n        IsEquivalentCircuit(a=>a < offset, a=>a, r, c1) &&\n        // The original c2 has an image in r.\n        IsEquivalentCircuit(a=>true, a=>a+offset, c2, r) &&\n        true\n\n\n",
        "output": "{ \n    var offset := |c1.nodes|;\n    var node_is_member := a=>true;\n    var node_map := a=>a+offset;\n    calc {\n        IsEquivalentCircuit(node_is_member, node_map, c2, r);\n        // Substitute in the IsEquivalentCircuit function definition.\n        forall inp :: inp in c2.backconns && node_is_member(inp.node_id) ==>\n            inodeport(node_map(inp.node_id), inp.port_id) in r.backconns &&\n            var inp2 := inodeport(node_map(inp.node_id), inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(node_map(onp.node_id), onp.port_id) == r.backconns[inp2];\n        // Substitute in the node_is_member and node_is_map definiions.\n        // For some reason this cause the solver to take too long.\n        forall inp :: inp in c2.backconns ==>\n            inodeport(inp.node_id+offset, inp.port_id) in r.backconns &&\n            var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(onp.node_id+offset, onp.port_id) == r.backconns[inp2];\n    }\n    assert basic_result: r.backconns == CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns)\n        by {\n            reveal r_is_result;\n        }\n\n    forall inp | inp in c2.backconns\n    {\n        calc {\n            inodeport(inp.node_id+offset, inp.port_id) in r.backconns &&\n            var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(onp.node_id+offset, onp.port_id) == r.backconns[inp2];\n\n            {reveal basic_result;}\n            inodeport(inp.node_id+offset, inp.port_id) in \n            CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns) &&\n            var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(onp.node_id+offset, onp.port_id) ==\n            CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns)[inp2];\n            \n            inodeport(inp.node_id+offset, inp.port_id) in \n            CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns) &&\n            var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n            var onp := c2.backconns[inp];\n            onodeport(onp.node_id+offset, onp.port_id) ==\n            CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns)[inp2];\n            {\n                var inp2 := inodeport(inp.node_id+offset, inp.port_id);\n                CombineBackconnsHelper2(\n                offset, c1.backconns, c2.backconns,\n                CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns),\n                inp\n                );\n                assert \n                    CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns)[inp2] ==\n                    onodeport(c2.backconns[inp].node_id+offset, c2.backconns[inp].port_id);\n                assert \n                    inodeport(inp.node_id+offset, inp.port_id) in \n                    CombineBackconns(|c1.nodes|, c1.backconns, c2.backconns);\n            }\n\n            true;\n        }\n    }\n    reveal r_is_result;\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction reverse(xs: seq<nat>): seq<nat>\n\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\n\nKnown Properties:\n\n\nProperty:\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\n    ensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n\n\n",
        "output": "{\n    if {\n        case xs == [] =>\n        calc {\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\n            assert zs[1..] == xs[1..] + ys;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction reverse(xs: seq<nat>): seq<nat>\n\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\n\nKnown Properties:\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\n    ensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n\n{\n    if {\n        case xs == [] =>\n        calc {\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\n            assert zs[1..] == xs[1..] + ys;\n        }\n    }\n}\n\n\n\nProperty:\nlemma ReverseInvolution(xxs: seq<nat>)\n    ensures reverse(reverse(xxs)) == xxs\n\n\n",
        "output": "{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Tree<T> = Leaf | Node(Tree<T>, Tree<T>, T)\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nfunction treeContains<T(==)>(tree:Tree<T>, element:T):bool\n\n{\n    match tree\n    case Leaf => false\n    case Node(l_tree, r_tree, v) => treeContains(l_tree,element) || treeContains(r_tree,element) || (v == element) \n}\n\nfunction listContains<T(==)>(xs:List<T>, element:T):bool\n\n{\n\tmatch xs\n    case Nil => false\n    case Cons(x,xs') => (x == element) || listContains(xs', element)\n}\n\nfunction append<T>(xs:List<T>, ys:List<T>):List<T>\n\n{\n\tmatch xs\n    case Nil => ys\n    case Cons(x,xs') => Cons(x, append(xs',ys))\n}\n\nfunction flatten<T>(tree:Tree<T>):List<T>\n\n{\n\tmatch tree\n    case Leaf => Nil\n    case Node(l_tree,r_tree,v) => Cons(v,append(flatten(l_tree),flatten(r_tree)))\n\n}\n\nKnown Properties:\nlemma memberOfAppend<T>(e:T, xs:List<T>, ys:List<T>)\n    ensures listContains(append(xs,ys),e) == ( listContains(xs,e)  ||  listContains(ys,e) )\n\n{}\n\n\n\nProperty:\nlemma sameElements<T>(tree:Tree<T>, element:T)\n    ensures treeContains(tree, element) <==> listContains(flatten(tree), element)\n\n\n",
        "output": "{\n    match tree\n    case Leaf => {}\n    case Node (l_tree,r_tree,v) => {\n        calc{treeContains(tree,element);\n        == treeContains(Node (l_tree,r_tree,v),element);\n        == treeContains(l_tree,element) || treeContains(r_tree,element) || (v==element);\n        == {sameElements(l_tree,element);\n           sameElements(r_tree,element);}\n        listContains(flatten(l_tree),element) || listContains(flatten(r_tree),element) || (v==element);\n        ==\n        {memberOfAppend(element,flatten(l_tree),flatten(r_tree));} \n        listContains(append(flatten(l_tree),flatten(r_tree)),element) || (v==element);\n        ==listContains(Cons(v,append(flatten(l_tree),flatten(r_tree))),element);\n        ==listContains(flatten(tree), element);\n        }      \n    }  \n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction expo(x:int, n:nat): int\n\n{\n    if n == 0 then 1\n    else x * expo(x, n-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Expon23(n: nat)\n    requires n >= 0\n    decreases n\n    ensures ((expo(2,3*n) - expo(3,n)) % (2+3)) == 0\n\n\n",
        "output": "{   \n    // base case\n    if (n == 0) {\n        assert (expo(2,3*0)-expo(3,0)) % 5 == 0;\n    }\n\n    else if (n == 1) {\n        assert (expo(2,3*1)-expo(3,1)) % 5 == 0;\n    }\n    else {\n        // assume false;\n        Expon23(n-1); // lemma proved for case n-1  \n        assert (expo(2,3*(n-1)) - expo(3,n-1)) % 5 == 0;\n        \n        // training dafny up\n        assert expo(2,3*n) == expo(2,3*(n-1)+2)*expo(2,1);\n        assert expo(2,3*n) == expo(2,3*(n-1)+3);\n\n        // training dafny up\n        assert expo(2,3*(n-1)+3) == expo(2,3*(n-1)+1)*expo(2,2);\n        assert expo(2,3*(n-1)+3) == expo(2,3*(n-1))*expo(2,3);\n        assert expo(3,(n-1)+1) == expo(3,(n-1))*expo(3,1);\n\n        // some more training\n        assert expo(3,n) == expo(3,n-1)*expo(3,1);\n        assert expo(3,n) == expo(3,(n-1)+1);\n\n        // not really needed\n        assert expo(2,3*(n-1))*expo(2,3) == expo(2,3*(n-1))*8;\n        assert expo(3,(n-1))*expo(3,1) == expo(3,(n-1))*3;\n\n\n        assert expo(2,3*n) - expo(3,n) == expo(2,3*(n-1)+3) - expo(3,(n-1)+1);\n    \n        assert (expo(2,3*n) - expo(3,n)) % 5 == (expo(2,3*(n-1)+3) - expo(3,(n-1)+1)) % 5; // rewriting it\n        assert (expo(2,3*n) - expo(3,n)) % 5 == (expo(2,3*(n-1))*expo(2,3) - expo(3,(n-1))*expo(3,1)) % 5; \n        assert (expo(2,3*n) - expo(3,n)) % 5 == (expo(2,3*(n-1))*8 - expo(3,(n-1))*3) % 5;\n        assert (expo(2,3*n) - expo(3,n)) % 5 == (expo(2,3*(n-1))*8 - expo(3,n-1)*8 + expo(3,n-1)*8 - expo(3,(n-1))*3) % 5; // imporant step to refactorize RHS\n        assert (expo(2,3*n) - expo(3,n)) % 5 == (8*(expo(2,3*(n-1)) - expo(3,n-1)) + expo(3,n-1)*(8-3)) % 5;\n        assert (expo(2,3*n) - expo(3,n)) % 5 == (8*(expo(2,3*(n-1)) - expo(3,n-1)) + expo(3,n-1)*(5)) % 5;\n        assert (expo(2,3*n) - expo(3,n)) % 5 == ((8*(expo(2,3*(n-1)) - expo(3,n-1))) % 5 + (expo(3,n-1)*(5)) % 5) % 5;\n        assert (expo(2,3*n) - expo(3,n)) % 5 == 0;\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(x:int, e:int):int\n    decreases e\n\trequires e >= 0\n    ensures x > 0 ==> exp(x,e) > 0\n\n{\n    if e == 0 then 1 else x*exp(x,e-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma mult8_Lemma(n:int)\n    decreases n\n\trequires n >= 1\n\tensures (exp(3,2*n) - 1)%8 == 0\n\n\n",
        "output": "{\n    if(n==1){\n    }\n    else{\n        calc =={\n            (exp(3,2*n) -1) % 8;\n            (exp(3, 2*(n-1)) *8 + exp(3,2*(n-1)) - 1) % 8;\n            {\n                mult8_Lemma(n-1);\n                assert exp(3,2*(n-1)) * 8 %8==0;\n            }\n            0;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SumR(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nKnown Properties:\nlemma concatLast(s:seq<int>,t:seq<int>)\n  requires t!=[]\n  ensures (s+t)[..|s+t|-1] == s+(t[..|t|-1])\n\n{}\n\n\n\nProperty:\nlemma SumByPartsR(s:seq<int>,t:seq<int>)\n  decreases s,t\n  ensures SumR(s+t) == SumR(s)+SumR(t)\n\n\n",
        "output": "{ \n  if (t==[])\n     {assert s+t == s;}\n  else if (s==[])\n     {assert s+t==t;}   \n  else\n     { \n       calc =={\n        SumR(s+t);\n        SumR((s+t)[..|s+t|-1])+(s+t)[|s+t|-1];\n        SumR((s+t)[..|s+t|-1])+t[|t|-1];\n        {concatLast(s,t);}\n        SumR(s+t[..|t|-1])+t[|t|-1];\n        {SumByPartsR(s,t[..|t|-1]);}\n        SumR(s)+SumR(t[..|t|-1])+t[|t|-1];\n        SumR(s)+SumR(t);\n       }\n     }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SumL(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\nKnown Properties:\nlemma concatFirst(s:seq<int>,t:seq<int>)\n  requires s!=[]\n  ensures (s+t)[1..] == s[1..]+t\n\n{}\n\n\n\nProperty:\nlemma SumByPartsL(s:seq<int>,t:seq<int>)\n  decreases s,t\n  ensures SumL(s+t) == SumL(s)+SumL(t)\n\n\n",
        "output": "{\n  if(t==[]){\n      assert s+t==s;\n  }\n  else if(s==[]){\n    assert s+t==t;\n  }\n  else{\n      calc == {\n        SumL(s+t);\n        (s+t)[0] + SumL((s+t)[1..]);\n        s[0] + SumL((s+t)[1..]);\n        {concatFirst(s,t);}\n        s[0] + SumL(s[1..] + t);\n        {SumByPartsL(s[1..], t);}\n        s[0] + SumL(s[1..]) + SumL(t);\n      }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SumR(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\nKnown Properties:\nlemma concatFirst(s:seq<int>,t:seq<int>)\n  requires s!=[]\n  ensures (s+t)[1..] == s[1..]+t\n\n{}\n\nlemma SumByPartsL(s:seq<int>,t:seq<int>)\n  decreases s,t\n  ensures SumL(s+t) == SumL(s)+SumL(t)\n\n{\n  if(t==[]){\n      assert s+t==s;\n  }\n  else if(s==[]){\n    assert s+t==t;\n  }\n  else{\n      calc == {\n        SumL(s+t);\n        (s+t)[0] + SumL((s+t)[1..]);\n        s[0] + SumL((s+t)[1..]);\n        {concatFirst(s,t);}\n        s[0] + SumL(s[1..] + t);\n        {SumByPartsL(s[1..], t);}\n        s[0] + SumL(s[1..]) + SumL(t);\n      }\n  }\n}\n\n\n\nProperty:\nlemma equalSumR(s:seq<int>,i:int,j:int)\n    decreases j-i\n    requires 0<=i<=j<=|s|\n    ensures  SumR(s[i..j])==SumL(s[i..j])\n\n\n",
        "output": "{\n  if(s==[]){\n    assert SumR(s) == SumL(s);\n  }else{\n    if(i==j){\n      assert SumR(s[i..j]) == SumL(s[i..j]);\n    }\n    else{\n      calc == {\n        SumR(s[i..j]);\n        {\n          assert s[i..j] == s[i..j-1] + [s[j-1]];\n          assert SumR(s[i..j]) == SumR(s[i..j-1]) + s[j-1];\n        }\n        SumR(s[i..j-1]) + s[j-1];\n        {equalSumR(s, i, j-1);}\n        SumL(s[i..j-1]) + s[j-1];\n        {assert s[j-1] == SumL([s[j-1]]);}\n        SumL(s[i..j-1]) + SumL([s[j-1]]);\n        {SumByPartsL(s[i..j-1], [s[j-1]]);}\n        SumL(s[i..j-1] + [s[j-1]]);\n        {\n          assert s[i..j] == s[i..j-1] + [s[j-1]];\n        }\n        SumL(s[i..j]);\n      }\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SumR(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else SumR(s[..|s|-1])+s[|s|-1]\n}\n\nfunction SumL(s:seq<int>):int\n  decreases s\n\n{\n    if (s==[]) then 0\n    else s[0]+SumL(s[1..])\n}\n\nKnown Properties:\nlemma concatFirst(s:seq<int>,t:seq<int>)\n  requires s!=[]\n  ensures (s+t)[1..] == s[1..]+t\n\n{}\n\nlemma SumByPartsL(s:seq<int>,t:seq<int>)\n  decreases s,t\n  ensures SumL(s+t) == SumL(s)+SumL(t)\n\n{\n  if(t==[]){\n      assert s+t==s;\n  }\n  else if(s==[]){\n    assert s+t==t;\n  }\n  else{\n      calc == {\n        SumL(s+t);\n        (s+t)[0] + SumL((s+t)[1..]);\n        s[0] + SumL((s+t)[1..]);\n        {concatFirst(s,t);}\n        s[0] + SumL(s[1..] + t);\n        {SumByPartsL(s[1..], t);}\n        s[0] + SumL(s[1..]) + SumL(t);\n      }\n  }\n}\n\nlemma equalSumR(s:seq<int>,i:int,j:int)\n    decreases j-i\n    requires 0<=i<=j<=|s|\n    ensures  SumR(s[i..j])==SumL(s[i..j])\n\n{\n  if(s==[]){\n    assert SumR(s) == SumL(s);\n  }else{\n    if(i==j){\n      assert SumR(s[i..j]) == SumL(s[i..j]);\n    }\n    else{\n      calc == {\n        SumR(s[i..j]);\n        {\n          assert s[i..j] == s[i..j-1] + [s[j-1]];\n          assert SumR(s[i..j]) == SumR(s[i..j-1]) + s[j-1];\n        }\n        SumR(s[i..j-1]) + s[j-1];\n        {equalSumR(s, i, j-1);}\n        SumL(s[i..j-1]) + s[j-1];\n        {assert s[j-1] == SumL([s[j-1]]);}\n        SumL(s[i..j-1]) + SumL([s[j-1]]);\n        {SumByPartsL(s[i..j-1], [s[j-1]]);}\n        SumL(s[i..j-1] + [s[j-1]]);\n        {\n          assert s[i..j] == s[i..j-1] + [s[j-1]];\n        }\n        SumL(s[i..j]);\n      }\n    }\n  }\n}\n\n\n\nProperty:\nlemma equalSumsV() \n    ensures forall v:array<int>,i,j | 0<=i<=j<=v.Length :: SumR(v[i..j])==SumL(v[i..j])\n\n\n",
        "output": "{ \n    forall v:array<int>,i,j | 0<=i<=j<=v.Length\n        ensures SumR(v[i..j])==SumL(v[i..j])\n    {\n        equalSumR(v[..],i,j);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction add(x:nat, y:nat): nat\n\n{\n  if(y == 0) then x\n  else add(x,y - 1) + 1\n}\n\nKnown Properties:\nlemma _for_add.dfy\n\nfunction add(x:nat, y:nat): nat\n\n{\n  if(y == 0) then x\n  else add(x,y - 1) + 1\n}\n\nlemma add_to_zero_lemma (x:nat, y:nat)\n  ensures add(x, y) == add(x, 0) + y\n\n{}\n\nlemma zero_to_add_lemma (x:nat, y:nat)\n  ensures add(x, y) == add(0, y) + x\n\n{}\n\n\n\nProperty:\nlemma add_comm_lemma(x: nat, y: nat)\n  ensures add(x,y) == add(y,x)\n\n\n",
        "output": "{\n  if (x == 0) {}\n  else if (y == 0) {}\n  else\n  {\n    calc\n    {\n      add(x, y);\n      {add_to_zero_lemma(x, y);}\n      add(x, 0) + y;\n      add(0, x) + y;\n      {zero_to_add_lemma(y, x);}\n      add(y, x);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction IsEven(n: int): bool\n  requires 0 <= n\n  ensures IsEven(n) ==> n == (n/2)+(n/2)\n\n{\n  (n/2)*2 == n\n}\n\nfunction Square(n: int): int \n{ n * n }\n\nfunction pow2_slow(n: int): int\n  requires 0 <= n\n\n{\n  if n == 0 then\n    1\n  else\n    2*pow2_slow(n-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Lemma(n: int)\n  requires 0 <= n && IsEven(n)\n  ensures pow2_slow(n) == Square(pow2_slow(n/2))\n\n\n",
        "output": "{\n  if n != 0 {\n    Lemma(n-2);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction IsEven(n: int): bool\n  requires 0 <= n\n  ensures IsEven(n) ==> n == (n/2)+(n/2)\n\n{\n  (n/2)*2 == n\n}\n\nfunction Square(n: int): int \n{ n * n }\n\nfunction pow2_slow(n: int): int\n  requires 0 <= n\n\n{\n  if n == 0 then\n    1\n  else\n    2*pow2_slow(n-1)\n}\n\nfunction pow2(n: int): int\n  requires 0 <= n\n  ensures 0 <= pow2(n)\n\n{\n  if n == 0 then\n    1\n  else if IsEven(n) then\n    Square(pow2(n / 2))\n  else\n    2*pow2(n-1)\n\n}\n\nKnown Properties:\nlemma Lemma(n: int)\n  requires 0 <= n && IsEven(n)\n  ensures pow2_slow(n) == Square(pow2_slow(n/2))\n\n{\n  if n != 0 {\n    Lemma(n-2);\n  }\n}\n\n\n\nProperty:\nlemma Theorem(n: int)\n  requires 0 <= n\n  ensures pow2(n) == pow2_slow(n)\n\n\n",
        "output": "{\n  if n == 0 {\n  } else if (IsEven(n)) {\n    Lemma(n);\n    Theorem(n/2);\n  } else {\n    Theorem(n-1);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Stream, whose values are possibly\n// infinite lists.\ncodatatype Stream<T> = SNil | SCons(head: T, tail: Stream<T>)\n\n// SAppend looks almost exactly like Append, but cannot have 'decreases'\n// clause, as it is possible it will never terminate.\nfunction SAppend(xs: Stream, ys: Stream): Stream\n\n{\n  match xs\n  case SNil => ys\n  case SCons(x, rest) => SCons(x, SAppend(rest, ys))\n}\n\nKnown Properties:\nlemma SAppendIsAssociativeK(k:nat, a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) ==#[k] SAppend(a, SAppend(b, c))\n  decreases k\n\n{}\n\n\n\nProperty:\nlemma SAppendIsAssociative(a:Stream, b:Stream, c:Stream)\n  ensures SAppend(SAppend(a, b), c) == SAppend(a, SAppend(b, c))\n\n\n",
        "output": "{\n  forall k:nat { SAppendIsAssociativeK(k, a, b, c); }\n  // assert for clarity only, postcondition follows directly from it\n  // assert (forall k:nat {:autotriggers false} :: SAppend(SAppend(a, b), c) ==#[k] SAppend(a, SAppend(b, c))); //FIXME: Should Dafny generate a trigger here? If so then which one?\n  assert (forall k:nat :: SAppend(SAppend(a, b), c) ==#[k] SAppend(a, SAppend(b, c))); //FIXME: Should Dafny generate a trigger here? If so then which one?\n\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction Fib(n: nat): nat\n  decreases n\n\n{ \n    if n < 2 then n else Fib(n-2) + Fib(n-1) \n}\n\nKnown Properties:\nlemma FibLemma(n: nat)\n  ensures Fib(n) % 2 == 0 <==> n % 3 == 0\n  decreases n\n\n{}\n\n\n\nProperty:\nlemma FibLemma_All()\n  ensures forall n :: 0 <= n ==> (Fib(n) % 2 == 0 <==> n % 3 == 0)\n\n\n",
        "output": "{\n  forall n | 0 <= n {\n    FibLemma(n);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Cons(hd: T, tl: Stream)\n\nfunction zip(xs: Stream, ys: Stream): Stream\n  \n{ Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) }\n\nfunction even(xs: Stream): Stream\n  \n{ Cons(xs.hd, even(xs.tl.tl)) }\n\nfunction odd(xs: Stream): Stream\n  \n{ even(xs.tl) }\n\nKnown Properties:\n\n\nProperty:\ngreatest lemma EvenOddLemma(xs: Stream)\n  ensures zip(even(xs), odd(xs)) == xs\n\n\n",
        "output": "{ \n  EvenOddLemma(xs.tl.tl); \n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Cons(hd: T, tl: Stream)\n\nfunction zip(xs: Stream, ys: Stream): Stream\n\n{ \n    Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) \n}\n\nfunction bzip(xs: Stream, ys: Stream, f:bool) : Stream\n\n{ \n    if f then Cons(xs.hd, bzip(xs.tl, ys, !f))\n    else      Cons(ys.hd, bzip(xs, ys.tl, !f)) \n}\n\nKnown Properties:\n\n\nProperty:\ngreatest lemma BzipZipLemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == bzip(xs, ys, true)\n\n\n",
        "output": "{ \n  BzipZipLemma(xs.tl, ys.tl); \n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Cons(hd: T, tl: Stream)\n\nfunction zip(xs: Stream, ys: Stream): Stream\n\n{ \n    Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) \n}\n\nfunction zip2(xs: Stream, ys: Stream): Stream\n\n{\n  Cons(xs.hd, zip2(ys, xs.tl))\n}\n\nKnown Properties:\n\n\nProperty:\ngreatest lemma ZipZip2Lemma(xs:Stream, ys:Stream)\n  ensures zip(xs, ys) == zip2(xs, ys)\n\n\n",
        "output": "{\n  ZipZip2Lemma(xs.tl, ys.tl);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Cons(hd: T, tl: Stream)\n\nfunction zip(xs: Stream, ys: Stream): Stream\n  \n{ Cons(xs.hd, Cons(ys.hd, zip(xs.tl, ys.tl))) }\n\nfunction even(xs: Stream): Stream\n  \n{ Cons(xs.hd, even(xs.tl.tl)) }\n\nfunction odd(xs: Stream): Stream\n  \n{ even(xs.tl) }\n\nfunction bswitch(xs: Stream, f:bool) : Stream\n\n{\n  if f then Cons(xs.tl.hd, bswitch(Cons(xs.hd, xs.tl.tl), !f))\n  else      Cons(xs.hd,      bswitch(xs.tl, !f))\n}\n\nKnown Properties:\n\n\nProperty:\ngreatest lemma BswitchLemma(xs:Stream)\n  ensures zip(odd(xs), even(xs)) == bswitch(xs, true)\n\n\n",
        "output": "{\n  BswitchLemma(xs.tl.tl);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Cons(head: T, tail: Stream)\ndatatype Bit = O | I\n\nfunction bitnot(b: Bit): Bit\n\n{\n  if b == O then I else O\n}\n\nfunction not(s: Stream<Bit>): Stream<Bit>\n\n{\n  Cons(bitnot(s.head), not(s.tail))\n}\n\nfunction f(s: Stream<Bit>): Stream<Bit>\n\n{\n  Cons(s.head, Cons(bitnot(s.head), f(s.tail)))\n}\n\nfunction zip(a: Stream, b: Stream): Stream \n{ Cons(a.head, zip(b, a.tail)) }\n\nKnown Properties:\n\n\nProperty:\ngreatest lemma FProperty(s: Stream<Bit>)\n  ensures f(s) == zip(s, not(s))\n\n\n",
        "output": "{\n  calc {\n    zip(s, not(s));\n    // def. zip\n    Cons(s.head, zip(not(s), s.tail));\n    // def. zip\n    Cons(s.head, Cons(not(s).head, zip(s.tail, not(s).tail)));\n  }\n  FProperty(s.tail);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\npredicate EVEN(n: nat)\n\n{\n  n % 2 == 0\n}\n\nfunction is defined like in the Pascal triangle.\n// \"binom(a, b)\" is also knows as \"a choose b\".\nfunction binom(a: nat, b: nat): nat\n\n{\n  if b == 0 then 1\n  else if a == 0 then 0\n  else binom(a-1, b) + binom(a-1, b-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma Lucas_Binary''(a: nat, b: nat)\n  ensures binom(a, b) % 2 == if EVEN(a) && !EVEN(b) then 0 else binom(a / 2, b / 2) % 2\n\n\n",
        "output": "{\n  if a == 0 || b == 0 {\n  } else {\n    Lucas_Binary''(a - 1, b);\n    Lucas_Binary''(a - 1, b - 1);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\npredicate gives the boolean value of bit \"k\" in\n// the natural number \"n\".\npredicate Bit(k: nat, n: nat)\n\n{\n  if k == 0 then n % 2 == 1\n  else Bit(k-1, n / 2)\n}\n\nfunction BitSet(n: nat): set<nat>\n\n{\n  set i | 0 <= i < n && Bit(i, n)\n}\n\nfunction applied pointwise to the\n// set.\nfunction Suc(S: set<nat>): set<nat>\n\n{\n  set x | x in S :: x + 1\n}\n\nKnown Properties:\nlemma shows that the \"i < n\" conjunct in\n// the set comprehension in \"BitSet\" does not restrict\n// the set any more than the conjunct \"Bit(i, n)\" does.\nlemma BitSize(i: nat, n: nat)\n  requires Bit(i, n)\n  ensures i < n\n\n{}\n\n\n\nProperty:\nlemma BitSet_Property(n: nat)\n  ensures BitSet(n) - \n\n",
        "output": "{0}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\npredicate gives the boolean value of bit \"k\" in\n// the natural number \"n\".\npredicate Bit(k: nat, n: nat)\n\n{\n  if k == 0 then n % 2 == 1\n  else Bit(k-1, n / 2)\n}\n\nfunction BitSet(n: nat): set<nat>\n\n{\n  set i | 0 <= i < n && Bit(i, n)\n}\n\npredicate EVEN(n: nat)\n\n{\n  n % 2 == 0\n}\n\nfunction is defined like in the Pascal triangle.\n// \"binom(a, b)\" is also knows as \"a choose b\".\nfunction binom(a: nat, b: nat): nat\n\n{\n  if b == 0 then 1\n  else if a == 0 then 0\n  else binom(a-1, b) + binom(a-1, b-1)\n}\n\nfunction applied pointwise to the\n// set.\nfunction Suc(S: set<nat>): set<nat>\n\n{\n  set x | x in S :: x + 1\n}\n\nKnown Properties:\nlemma Lucas_Binary''(a: nat, b: nat)\n  ensures binom(a, b) % 2 == if EVEN(a) && !EVEN(b) then 0 else binom(a / 2, b / 2) % 2\n\n{\n  if a == 0 || b == 0 {\n  } else {\n    Lucas_Binary''(a - 1, b);\n    Lucas_Binary''(a - 1, b - 1);\n  }\n}\n\nlemma clearly shows the correspondence between\n// \"S\" and \"Suc(S)\".\nlemma SucElements(S: set<nat>)\n  ensures forall x :: x in S <==> (x+1) in Suc(S)\n\n{}\n\nlemma shows that the \"i < n\" conjunct in\n// the set comprehension in \"BitSet\" does not restrict\n// the set any more than the conjunct \"Bit(i, n)\" does.\nlemma BitSize(i: nat, n: nat)\n  requires Bit(i, n)\n  ensures i < n\n\n{}\n\nlemma that relates BitSet and Suc.\nlemma BitSet_Property(n: nat)\n  ensures BitSet(n) - \n{0}\n\n\n\nProperty:\nlemma Lucas_Theorem'(m: nat, n: nat)\n  ensures BitSet(m) <= BitSet(n) <==> !EVEN(binom(n, m))\n\n\n",
        "output": "{\n  if m == 0 && n == 0 {\n  } else if EVEN(n) && !EVEN(m) {\n    calc {\n      !EVEN(binom(n, m));\n    ==  \n    { Lucas_Binary''(n, m); }\n      false;\n    ==  { assert 0 in BitSet(m) && 0 !in BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  } else {\n    var m', n' := m/2, n/2;\n    calc {\n      !EVEN(binom(n, m));\n    ==  \n    { Lucas_Binary''(n, m); }\n      !EVEN(binom(n', m'));\n    ==  { Lucas_Theorem'(m', n'); }\n      BitSet(m') <= BitSet(n');\n    ==  \n    { SucElements(BitSet(m')); SucElements(BitSet(n')); }\n      Suc(BitSet(m')) <= Suc(BitSet(n'));\n    ==  \n    { BitSet_Property(m); BitSet_Property(n); }\n      BitSet(m) - {0} <= BitSet(n) - {0};\n    ==  { assert 0 !in BitSet(m) ==> BitSet(m) == BitSet(m) - {0};\n          assert 0 in BitSet(n) ==> BitSet(n) - {0} <= BitSet(n); }\n      BitSet(m) <= BitSet(n);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nfunction append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, xs') => Cons(x, append(xs', ys))\n}\n\nfunction Bind<T,U>(xs: List<T>, f: T -> List<U>): List<U>\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs') => append(f(x), Bind(xs', f))\n}\n\nfunction Return<T>(a: T): List\n\n{\n  Cons(a, Nil)\n}\n\nKnown Properties:\nlemma AppendNil(xs: List)\n  ensures append(xs, Nil) == xs\n\n{}\n\n\n\nProperty:\nlemma LeftIdentity<T>(a: T, f: T -> List)\n  ensures Bind(Return(a), f) == f(a)\n\n\n",
        "output": "{\n  AppendNil(f(a));\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nfunction append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, xs') => Cons(x, append(xs', ys))\n}\n\nfunction Bind<T,U>(xs: List<T>, f: T -> List<U>): List<U>\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs') => append(f(x), Bind(xs', f))\n}\n\nfunction Return<T>(a: T): List\n\n{\n  Cons(a, Nil)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma RightIdentity<T>(m: List)\n  ensures Bind(m, Return) == m\n\n\n",
        "output": "{\n  match m\n  case Nil =>\n    assert Bind<T,T>(Nil, Return) == Nil;\n  case Cons(x, m') =>\n    calc {\n      Bind(Cons(x, m'), Return);\n      append(Return(x), Bind(m', Return));\n      Cons(x, Bind(m', Return));\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nfunction append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, xs') => Cons(x, append(xs', ys))\n}\n\nfunction Bind<T,U>(xs: List<T>, f: T -> List<U>): List<U>\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs') => append(f(x), Bind(xs', f))\n}\n\nKnown Properties:\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n\n{}\n\n\n\nProperty:\nlemma BindOverAppend<T>(xs: List, ys: List, g: T -> List)\n  ensures Bind(append(xs, ys), g) == append(Bind(xs, g), Bind(ys, g))\n\n\n",
        "output": "{\n  match xs\n  case Nil =>\n  case Cons(x, xs') =>\n    AppendAssoc(g(x), Bind(xs', g), Bind(ys, g));\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nfunction append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, xs') => Cons(x, append(xs', ys))\n}\n\nfunction Bind<T,U>(xs: List<T>, f: T -> List<U>): List<U>\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, xs') => append(f(x), Bind(xs', f))\n}\n\nKnown Properties:\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n\n{}\n\nlemma BindOverAppend<T>(xs: List, ys: List, g: T -> List)\n  ensures Bind(append(xs, ys), g) == append(Bind(xs, g), Bind(ys, g))\n\n{\n  match xs\n  case Nil =>\n  case Cons(x, xs') =>\n    AppendAssoc(g(x), Bind(xs', g), Bind(ys, g));\n}\n\n\n\nProperty:\nlemma Associativity<T>(m: List, f: T -> List, g: T -> List)\n  ensures Bind(Bind(m, f), g) == Bind(m, x => Bind(f(x), g))\n\n\n",
        "output": "{\n  match m\n  case Nil =>\n    assert Bind(m, x => Bind(f(x), g)) == Nil;\n  case Cons(x, xs) =>\n    match f(x)\n    case Nil =>\n      calc {\n        Bind(xs, y => Bind(f(y), g));\n        Bind(Cons(x, xs), y => Bind(f(y), g));\n      }\n    case Cons(y, ys) =>\n      calc {\n        append(g(y), Bind(append(ys, Bind(xs, f)), g));\n        { BindOverAppend(ys, Bind(xs, f), g); }\n        append(g(y), append(Bind(ys, g), Bind(Bind(xs, f), g)));\n        { AppendAssoc(g(y), Bind(ys, g), Bind(Bind(xs, f), g)); }\n        append(append(g(y), Bind(ys, g)), Bind(Bind(xs, f), g));\n        Bind(Cons(x, xs), z => Bind(f(z), g));\n      }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction Sum(n: nat, f: int -> int): int\n\n{\n  if n == 0 then 0 else f(n-1) + Sum(n-1, f)\n}\n\nKnown Properties:\nlemma Exchange(n: nat, f: int -> int, g: int -> int)\n  requires forall i :: 0 <= i < n ==> f(i) == g(i)\n  ensures Sum(n, f) == Sum(n, g)\n\n{}\n\n\n\nProperty:\nlemma BetaReductionInside(n': nat, g: (int,int) -> int)\n  ensures Sum(n', x => g(x,n') + Sum(n', y => g(x,y)))\n       == Sum(n', x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x))\n\n\n",
        "output": "{\n  Exchange(n', x => g(x,n') + Sum(n', y => g(x,y)), x => (w => g(w,n'))(x) + (w => Sum(n', y => g(w,y)))(x));\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Tree = Empty | Node(int,Tree,Tree)\n\npredicate Ascending(q: seq<int>)\n\n{\n\tforall i,j :: 0 <= i < j < |q| ==> q[i] < q[j]\n}\n\nfunction Inorder(t: Tree): seq<int>\n\n{\n\tmatch t {\n\t\tcase Empty => []\n\t\tcase Node(n',nt1,nt2) => Inorder(nt1)+[n']+Inorder(nt2)\n\t}\n}\n\npredicate BST(t: Tree)\n\n{\n\tAscending(Inorder(t))\n}\n\nKnown Properties:\nlemma LemmaAscendingSubsequence(q1: seq<int>, q2: seq<int>, i: nat)\n\trequires i <= |q1|-|q2| && q2 == q1[i..i+|q2|]\n\trequires Ascending(q1)\n\tensures Ascending(q2)\n\n{}\n\n\n\nProperty:\nlemma LemmaBinarySearchSubtree(n: int, left: Tree, right: Tree)\n\trequires BST(Node(n, left, right))\n\tensures BST(left) && BST(right)\n\n\n",
        "output": "{\n\tassert Ascending(Inorder(Node(n, left, right)));\n\tvar qleft, qright := Inorder(left), Inorder(right);\n\tvar q := qleft+[n]+qright;\n\tassert q == Inorder(Node(n, left, right));\n\tassert Ascending(qleft+[n]+qright);\n\tassert Ascending(qleft) by { LemmaAscendingSubsequence(q, qleft, 0); }\n\tassert Ascending(qright) by { LemmaAscendingSubsequence(q, qright, |qleft|+1); }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursiveSumDown(str: string): int\n\tdecreases |str|\n\n{\n\tif str == \"\" then 0 else str[|str|-1] as int +RecursiveSumDown(str[..|str|-1])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma LemmaAddingOneIndex(str: string, i: nat, sum: int)\n\trequires 0 <= i < |str| && sum == RecursiveSumDown(str[..i])\n\tensures 0 <= i+1 <= |str| && sum + str[i] as int == RecursiveSumDown(str[..i+1])\n\n\n",
        "output": "{\n\tvar str1 := str[..i+1];\n\tcalc {\n\t\tRecursiveSumDown(str[..i+1]);\n\t== // def.\n\t\tif str1 == [] then 0 else str1[|str1|-1] as int + RecursiveSumDown(str1[..|str1|-1]);\n\t== { assert str1 != []; } // simplification for a non-empty sequence\n\t\tstr1[|str1|-1] as int + RecursiveSumDown(str1[..|str1|-1]);\n\t== { assert |str1|-1 == i; }\n\t\tstr1[i] as int + RecursiveSumDown(str1[..i]);\n\t== { assert str1[..i] == str[..i]; }\n\t\tstr[i] as int + RecursiveSumDown(str[..i]);\n\t== // inv.\n\t\tstr[i] as int + sum;\n\t==\n\t\tsum + str[i] as int;\n\t}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursiveSumDown(str: string): int\n\tdecreases |str|\n\n{\n\tif str == \"\" then 0 else str[|str|-1] as int +RecursiveSumDown(str[..|str|-1])\n}\n\nfunction RecursiveSumUp(str: string): int\n\tdecreases |str|\n\n{\n\tif str == \"\" then 0 else str[0] as int + RecursiveSumUp(str[1..])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma EquivalentSumDefinitions(str: string)\n\tensures RecursiveSumDown(str) == RecursiveSumUp(str)\n\tdecreases |str|\n\n\n",
        "output": "{\n\tif |str| == 0\n\t{\n\t\tassert str == \"\";\n\t\tassert RecursiveSumDown([]) == 0 == RecursiveSumUp([]);\n\t}\n\telse if |str| == 1\n\t{\n\t\tassert str == [str[0]];\n\t\tassert RecursiveSumDown(str) == str[0] as int  == RecursiveSumUp(str);\n\t}\n\telse\n\t{\n\t\tassert |str| >= 2;\n\t\tvar first: char, mid: string, last:char := str[0], str[1..|str|-1], str[|str|-1];\n\t\tassert str == [first] + mid + [last];\n\t\tcalc {\n\t\t\tRecursiveSumDown(str);\n\t\t== { assert str != [] && str[|str|-1] == last && str[..|str|-1] == [first] + mid; }\n\t\t\tlast as int + RecursiveSumDown([first] + mid);\n\t\t== // arithmetic\n\t\t\tRecursiveSumDown([first] + mid) + last as int;\n\t\t== { EquivalentSumDefinitions([first] + mid); } // induction hypothesis\n\t\t\tRecursiveSumUp([first] + mid) + last as int;\n\t\t== { assert [first] + mid != []; }\n\t\t\tfirst as int + RecursiveSumUp(mid) + last as int;\n\t\t== { EquivalentSumDefinitions(mid); } // induction hypothesis\n\t\t\tfirst as int + RecursiveSumDown(mid) + last as int;\n\t\t==\n\t\t\tfirst as int + RecursiveSumDown(mid + [last]);\n\t\t== { EquivalentSumDefinitions(mid + [last]); } // induction hypothesis\n\t\t\tfirst as int + RecursiveSumUp(mid + [last]);\n\t\t== { assert str != [] && str[0] == first && str[1..] == mid + [last]; }\n\t\t\tRecursiveSumUp(str);\n\t\t}\n\t}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction RecursiveSumDown(str: string): int\n\tdecreases |str|\n\n{\n\tif str == \"\" then 0 else str[|str|-1] as int +RecursiveSumDown(str[..|str|-1])\n}\n\nfunction RecursiveSumUp(str: string): int\n\tdecreases |str|\n\n{\n\tif str == \"\" then 0 else str[0] as int + RecursiveSumUp(str[1..])\n}\n\nKnown Properties:\nlemma LemmaAddingOneIndex(str: string, i: nat, sum: int)\n\trequires 0 <= i < |str| && sum == RecursiveSumDown(str[..i])\n\tensures 0 <= i+1 <= |str| && sum + str[i] as int == RecursiveSumDown(str[..i+1])\n\n{\n\tvar str1 := str[..i+1];\n\tcalc {\n\t\tRecursiveSumDown(str[..i+1]);\n\t== // def.\n\t\tif str1 == [] then 0 else str1[|str1|-1] as int + RecursiveSumDown(str1[..|str1|-1]);\n\t== { assert str1 != []; } // simplification for a non-empty sequence\n\t\tstr1[|str1|-1] as int + RecursiveSumDown(str1[..|str1|-1]);\n\t== { assert |str1|-1 == i; }\n\t\tstr1[i] as int + RecursiveSumDown(str1[..i]);\n\t== { assert str1[..i] == str[..i]; }\n\t\tstr[i] as int + RecursiveSumDown(str[..i]);\n\t== // inv.\n\t\tstr[i] as int + sum;\n\t==\n\t\tsum + str[i] as int;\n\t}\n}\n\nlemma EquivalentSumDefinitions(str: string)\n\tensures RecursiveSumDown(str) == RecursiveSumUp(str)\n\tdecreases |str|\n\n{\n\tif |str| == 0\n\t{\n\t\tassert str == \"\";\n\t\tassert RecursiveSumDown([]) == 0 == RecursiveSumUp([]);\n\t}\n\telse if |str| == 1\n\t{\n\t\tassert str == [str[0]];\n\t\tassert RecursiveSumDown(str) == str[0] as int  == RecursiveSumUp(str);\n\t}\n\telse\n\t{\n\t\tassert |str| >= 2;\n\t\tvar first: char, mid: string, last:char := str[0], str[1..|str|-1], str[|str|-1];\n\t\tassert str == [first] + mid + [last];\n\t\tcalc {\n\t\t\tRecursiveSumDown(str);\n\t\t== { assert str != [] && str[|str|-1] == last && str[..|str|-1] == [first] + mid; }\n\t\t\tlast as int + RecursiveSumDown([first] + mid);\n\t\t== // arithmetic\n\t\t\tRecursiveSumDown([first] + mid) + last as int;\n\t\t== { EquivalentSumDefinitions([first] + mid); } // induction hypothesis\n\t\t\tRecursiveSumUp([first] + mid) + last as int;\n\t\t== { assert [first] + mid != []; }\n\t\t\tfirst as int + RecursiveSumUp(mid) + last as int;\n\t\t== { EquivalentSumDefinitions(mid); } // induction hypothesis\n\t\t\tfirst as int + RecursiveSumDown(mid) + last as int;\n\t\t==\n\t\t\tfirst as int + RecursiveSumDown(mid + [last]);\n\t\t== { EquivalentSumDefinitions(mid + [last]); } // induction hypothesis\n\t\t\tfirst as int + RecursiveSumUp(mid + [last]);\n\t\t== { assert str != [] && str[0] == first && str[1..] == mid + [last]; }\n\t\t\tRecursiveSumUp(str);\n\t\t}\n\t}\n}\n\n\n\nProperty:\nlemma LemmaHashEqualty(text_hash : int, text: string, i: nat, old_text_hash: int, pattern: string)\n\trequires 0 < i <= |text| - |pattern|\n\trequires text_hash == old_text_hash - text[i - 1] as int + text[i - 1 + |pattern|] as int\n\trequires  old_text_hash == RecursiveSumDown(text[i - 1..i - 1 + |pattern|]);\n\tensures text_hash == RecursiveSumDown(text[i..i+|pattern|])\n\n\n",
        "output": "{\n\tassert 0 < i <= |text| - |pattern|;\n\tassert 0 <= i - 1 < |text| - |pattern|;\n\tghost var temp_val := old_text_hash + text[i - 1 + |pattern|] as int;\n\tassert text_hash == old_text_hash + text[i - 1 + |pattern|] as int - text[i - 1] as int;\n\t//=>\n\tassert text_hash == temp_val - text[i - 1] as int;\n\tassert 0 <= |pattern| < |text[i - 1..]|;\n\tghost var str := text[i - 1..];\n\tassert str[..|pattern|] == text[i - 1 .. i - 1 + |pattern|];\n\tassert old_text_hash == RecursiveSumDown(str[..|pattern|]);\n\tLemmaAddingOneIndex(str, |pattern|, old_text_hash);\n\tassert old_text_hash + str[|pattern|] as int == RecursiveSumDown(str[..|pattern|+1]);\n\tassert str[..|pattern|+1] == text[i - 1..i - 1 + |pattern| + 1];\n\t//=>\n\tassert old_text_hash + text[i - 1 + |pattern|] as int == RecursiveSumDown(text[i - 1..i - 1 + |pattern| + 1]);\n\tassert temp_val == old_text_hash + text[i - 1 + |pattern|] as int;\n\t//=>\n\tassert temp_val == RecursiveSumDown(text[i - 1..i - 1 + |pattern| + 1]);\n\tassert temp_val == RecursiveSumDown(text[i - 1..i + |pattern|]);\n\t// PrependSumUp(text[i - 1..i + |pattern|]);\n\tassert RecursiveSumUp(text[i - 1..i + |pattern|]) == text[i - 1] as int + RecursiveSumUp(text[i..i + |pattern|]);\n\tEquivalentSumDefinitions(text[i - 1..i + |pattern|]);\n\tEquivalentSumDefinitions(text[i..i + |pattern|]);\n\t//=>\n\tassert RecursiveSumUp(text[i - 1..i + |pattern|]) == RecursiveSumDown(text[i - 1..i + |pattern|]);\n\tassert RecursiveSumUp(text[i..i + |pattern|]) == RecursiveSumDown(text[i..i + |pattern|]);\n\t//=>\n\tassert RecursiveSumDown(text[i - 1..i + |pattern|]) == text[i - 1] as int + RecursiveSumDown(text[i..i + |pattern|]);\n\t//=>\n\tassert RecursiveSumDown(text[i - 1..i + |pattern|]) - text[i - 1] as int == RecursiveSumDown(text[i..i + |pattern|]);\n\tassert text_hash == temp_val - text[i - 1] as int;\n\tassert temp_val == RecursiveSumDown(text[i - 1..i + |pattern|]);\n\tassert text_hash == RecursiveSumDown(text[i - 1..i + |pattern|]) - text[i - 1] as int;\n\t//=>\n\tassert text_hash == RecursiveSumDown(text[i..i + |pattern|]);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n\n{\n  if (x in c) then Some(c[x]) else None\n}\n\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n\n{\n  c[x:=T]\n}\n\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t\n\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\n\nfunction fv(t: tm): set<int> //of free variables of t\n\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\n\ntype soundness of closed terms.\npredicate closed(t: tm)\n\n{\n  forall x :: x !in fv(t)\n}\n\nKnown Properties:\nlemma lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t)\n  requires has_type(c, t).Some?\n  ensures find(c, x).Some?\n  decreases t\n\n{}\n\n\n\nProperty:\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?\n  ensures closed(t)\n\n\n",
        "output": "{\n  forall (x:int) ensures x !in fv(t)\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n\n{\n  if (x in c) then Some(c[x]) else None\n}\n\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n\n{\n  c[x:=T]\n}\n\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t\n\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\n\nfunction fv(t: tm): set<int> //of free variables of t\n\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\n\ntype as in context c.\nlemma \n{:induction t}\n\nKnown Properties:\n\n\nProperty:\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x)\n  ensures has_type(c, t) == has_type(c', t)\n  decreases t\n\n\n",
        "output": "{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n\n{\n  if (x in c) then Some(c[x]) else None\n}\n\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n\n{\n  c[x:=T]\n}\n\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t\n\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\n\nfunction fv(t: tm): set<int> //of free variables of t\n\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\n\nfunction subst(x: int, s: tm, t: tm): tm //[x -> s]t\n\n{\n  match t\n  // interesting cases...\n  case tvar(x') => if x==x' then s else t\n  // N.B. only capture-avoiding if s is closed...\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  // congruent cases...\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n}\n\ntype as in context c.\nlemma \n{:induction t}\n\ntype soundness of closed terms.\npredicate closed(t: tm)\n\n{\n  forall x :: x !in fv(t)\n}\n\ntype S in an empty context,\n// and t has type T in a context extended with x having type S,\n// then [x -> s]t has type T as well.\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\nKnown Properties:\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x)\n  ensures has_type(c, t) == has_type(c', t)\n  decreases t\n\n{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\n\nlemma lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t)\n  requires has_type(c, t).Some?\n  ensures find(c, x).Some?\n  decreases t\n\n{}\n\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?\n  ensures closed(t)\n\n{\n  forall (x:int) ensures x !in fv(t)\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n    }\n  }\n}\n\n\n\nProperty:\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n\n",
        "output": "{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n\n{\n  if (x in c) then Some(c[x]) else None\n}\n\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n\n{\n  c[x:=T]\n}\n\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t\n\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\n\nfunction fv(t: tm): set<int> //of free variables of t\n\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\n\nfunction subst(x: int, s: tm, t: tm): tm //[x -> s]t\n\n{\n  match t\n  // interesting cases...\n  case tvar(x') => if x==x' then s else t\n  // N.B. only capture-avoiding if s is closed...\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  // congruent cases...\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n}\n\npredicate value(t: tm)\n\n{\n  t.tabs?\n}\n\nfunction step(t: tm): option<tm>\n\n{\n  /* AppAbs */     if (t.tapp? && t.f.tabs? && value(t.arg)) then\n  Some(subst(t.f.x, t.arg, t.f.body))\n  /* App1 */       else if (t.tapp? && step(t.f).Some?) then\n  Some(tapp(step(t.f).get, t.arg))\n  /* App2 */       else if (t.tapp? && value(t.f) && step(t.arg).Some?) then\n  Some(tapp(t.f, step(t.arg).get))\n\n  else None\n}\n\ntype as in context c.\nlemma \n{:induction t}\n\ntype soundness of closed terms.\npredicate closed(t: tm)\n\n{\n  forall x :: x !in fv(t)\n}\n\ntype S in an empty context,\n// and t has type T in a context extended with x having type S,\n// then [x -> s]t has type T as well.\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\ntype term which steps preserves its type.\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?\n  requires step(t).Some?\n  ensures has_type(map[], step(t).get) == has_type(map[], t)\n\n{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\n\nKnown Properties:\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x)\n  ensures has_type(c, t) == has_type(c', t)\n  decreases t\n\n{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\n\nlemma lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t)\n  requires has_type(c, t).Some?\n  ensures find(c, x).Some?\n  decreases t\n\n{}\n\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?\n  ensures closed(t)\n\n{\n  forall (x:int) ensures x !in fv(t)\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n    }\n  }\n}\n\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\n\n\nProperty:\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?\n  requires step(t).Some?\n  ensures has_type(map[], step(t).get) == has_type(map[], t)\n\n\n",
        "output": "{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ty =  TBase                             // (opaque base type)\n            |  TArrow(T1: ty, T2: ty)            // T1 => T2\n\n// Terms\ndatatype tm = tvar(id: int)                      // x                  (variable)\n            | tapp(f: tm, arg: tm)               // t t                (application)\n            | tabs(x: int, T: ty, body: tm)      // \\x:T.t             (abstraction)\n\n// ... handy for partial functions\ndatatype option<A> = None | Some(get: A)\n\n// A context is a partial map from variable names to types.\nfunction find(c: map<int,ty>, x: int): option<ty>\n\n{\n  if (x in c) then Some(c[x]) else None\n}\n\nfunction extend(x: int, T: ty, c: map<int,ty>): map<int,ty>\n\n{\n  c[x:=T]\n}\n\nfunction has_type(c: map<int,ty>, t: tm): option<ty>\n  decreases t\n\n{\n  match t\n  /* Var */  case tvar(id) => find(c, id)\n  /* Abs */  case tabs(x, T, body) =>\n  var ty_body := has_type(extend(x, T, c), body);\n                     if (ty_body.Some?) then\n  Some(TArrow(T, ty_body.get))          else None\n  /* App */  case tapp(f, arg) =>\n  var ty_f   := has_type(c, f);\n  var ty_arg := has_type(c, arg);\n                     if (ty_f.Some? && ty_arg.Some?) then\n  if ty_f.get.TArrow? && ty_f.get.T1 == ty_arg.get then\n  Some(ty_f.get.T2)  else None else None\n}\n\nfunction fv(t: tm): set<int> //of free variables of t\n\n{\n  match t\n  // interesting cases...\n  case tvar(id) => {id}\n  case tabs(x, T, body) => fv(body)-{x}//x is bound\n  // congruent cases...\n  case tapp(f, arg) => fv(f)+fv(arg)\n}\n\nfunction subst(x: int, s: tm, t: tm): tm //[x -> s]t\n\n{\n  match t\n  // interesting cases...\n  case tvar(x') => if x==x' then s else t\n  // N.B. only capture-avoiding if s is closed...\n  case tabs(x', T, t1) => tabs(x', T, if x==x' then t1 else subst(x, s, t1))\n  // congruent cases...\n  case tapp(t1, t2) => tapp(subst(x, s, t1), subst(x, s, t2))\n}\n\npredicate value(t: tm)\n\n{\n  t.tabs?\n}\n\nfunction step(t: tm): option<tm>\n\n{\n  /* AppAbs */     if (t.tapp? && t.f.tabs? && value(t.arg)) then\n  Some(subst(t.f.x, t.arg, t.f.body))\n  /* App1 */       else if (t.tapp? && step(t.f).Some?) then\n  Some(tapp(step(t.f).get, t.arg))\n  /* App2 */       else if (t.tapp? && value(t.f) && step(t.arg).Some?) then\n  Some(tapp(t.f, step(t.arg).get))\n\n  else None\n}\n\npredicate reduces_to(t: tm, t': tm, n: nat)\n  decreases n\n\n{\n  t == t' || (n > 0 && step(t).Some? && reduces_to(step(t).get, t', n-1))\n}\n\npredicate normal_form(t: tm)\n\n{\n  step(t).None?\n}\n\npredicate stuck(t: tm)\n\n{\n  normal_form(t) && !value(t)\n}\n\ntype as in context c.\nlemma \n{:induction t}\n\ntype soundness of closed terms.\npredicate closed(t: tm)\n\n{\n  forall x :: x !in fv(t)\n}\n\ntype S in an empty context,\n// and t has type T in a context extended with x having type S,\n// then [x -> s]t has type T as well.\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\ntype term which steps preserves its type.\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?\n  requires step(t).Some?\n  ensures has_type(map[], step(t).get) == has_type(map[], t)\n\n{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\n\nKnown Properties:\nlemma {:induction t} lemma_context_invariance(c: map<int,ty>, c': map<int,ty>, t: tm)\n  requires has_type(c, t).Some?\n  requires forall x: int :: x in fv(t) ==> find(c, x) == find(c', x)\n  ensures has_type(c, t) == has_type(c', t)\n  decreases t\n\n{\n  if (t.tabs?) {\n    assert fv(t.body) == fv(t) || fv(t.body) == fv(t) + {t.x};\n    lemma_context_invariance(extend(t.x, t.T, c), extend(t.x, t.T, c'), t.body);\n  }\n}\n\nlemma lemma_free_in_context(c: map<int,ty>, x: int, t: tm)\n  requires x in fv(t)\n  requires has_type(c, t).Some?\n  ensures find(c, x).Some?\n  decreases t\n\n{}\n\nlemma corollary_typable_empty__closed(t: tm)\n  requires has_type(map[], t).Some?\n  ensures closed(t)\n\n{\n  forall (x:int) ensures x !in fv(t)\n  {\n    if (x in fv(t)) {\n      lemma_free_in_context(map[], x, t);\n    }\n  }\n}\n\nlemma lemma_substitution_preserves_typing(c: map<int,ty>, x: int, s: tm, t: tm)\n  requires has_type(map[], s).Some?\n  requires has_type(extend(x, has_type(map[], s).get, c), t).Some?\n  ensures has_type(c, subst(x, s, t)) == has_type(extend(x, has_type(map[], s).get, c), t)\n  decreases t\n\n{\n  var S := has_type(map[], s).get;\n  var cs := extend(x, S, c);\n  var T  := has_type(cs, t).get;\n\n  if (t.tvar?) {\n    if (t.id==x) {\n      assert T == S;\n      corollary_typable_empty__closed(s);\n      lemma_context_invariance(map[], c, s);\n    }\n  }\n  if (t.tabs?) {\n    if (t.x==x) {\n      lemma_context_invariance(cs, c, t);\n    } else {\n      var cx  := extend(t.x, t.T, c);\n      var csx := extend(x, S, cx);\n      var cxs := extend(t.x, t.T, cs);\n      lemma_context_invariance(cxs, csx, t.body);\n      lemma_substitution_preserves_typing(cx, x, s, t.body);\n    }\n  }\n}\n\nlemma theorem_preservation(t: tm)\n  requires has_type(map[], t).Some?\n  requires step(t).Some?\n  ensures has_type(map[], step(t).get) == has_type(map[], t)\n\n{\n  if (t.tapp? && value(t.f) && value(t.arg)) {\n    lemma_substitution_preserves_typing(map[], t.f.x, t.arg, t.f.body);\n  }\n}\n\nlemma theorem_progress(t: tm)\n  requires has_type(map[], t).Some?\n  ensures value(t) || step(t).Some?\n\n{}\n\n\n\nProperty:\nlemma corollary_soundness(t: tm, t': tm, T: ty, n: nat)\n  requires has_type(map[], t) == Some(T)\n  requires reduces_to(t, t', n)\n  ensures !stuck(t')\n  decreases n\n\n\n",
        "output": "{\n  theorem_progress(t);\n  if (t != t') {\n   theorem_preservation(t);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction Power(b: nat, n: nat): (p: nat)\n    ensures b > 0 ==> p > 0\n\n{\n    match n\n    case 0 => 1\n    case 1 => b\n    case _ => b * Power(b, n - 1)\n}\n\nfunction Log2Floor(n: nat): nat\n    requires n >= 1\n    decreases n\n\n{\n    if n < 2 then 0\n    else Log2Floor(n / 2) + 1\n}\n\nKnown Properties:\nlemma Power2OfLog2Floor(n: nat)\n    requires n >= 1\n    ensures Power(2, Log2Floor(n)) <= n < Power(2, Log2Floor(n) + 1)\n\n{}\n\nlemma Log2FloorDef(n: nat)\n    requires n >= 1\n    ensures Log2Floor(2 * n) == Log2Floor(n) + 1\n\n{}\n\n\n\nProperty:\nlemma NLtPower2Log2FloorOf2N(n: nat)\n    requires n >= 1\n    ensures n < Power(2, Log2Floor(2 * n))\n\n\n",
        "output": "{\n    calc {\n        n;\n    < { Power2OfLog2Floor(n); }\n        Power(2, Log2Floor(n) + 1);\n    == \n    { Log2FloorDef(n); }\n        Power(2, Log2Floor(2 * n));\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Nat = Zero | S(Pred: Nat)\n\nfunction Add(x: Nat, y: Nat) : Nat\n    decreases y\n\n{\n    match y\n        case Zero => x\n        case S(y') => S(Add(x, y')) \n}\n\nKnown Properties:\nlemma ZeroAddCommutative(n: Nat)\n    ensures Add(Zero, n) == Add(n, Zero)\n\n{}\n\n\n\nProperty:\nlemma AddCommutative(x: Nat, y: Nat)\n    ensures Add(x, y) == Add(y, x)\n    decreases x, y\n\n\n",
        "output": "{\n    match x\n        case Zero => ZeroAddCommutative(y);\n        case S(x') => AddCommutative(x', y);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Nat = Zero | S(Pred: Nat)\n\nfunction Add(x: Nat, y: Nat) : Nat\n    decreases y\n\n{\n    match y\n        case Zero => x\n        case S(y') => S(Add(x, y')) \n}\n\nKnown Properties:\nlemma ZeroAddAssociative(x: Nat, y: Nat)\n    ensures Add(Add(Zero, x), y) == Add(Zero, Add(x, y))\n\n{}\n\n\n\nProperty:\nlemma AddAssociative(x: Nat, y: Nat, z: Nat)\n    ensures Add(Add(x, y), z) == Add(x, Add(y, z))\n    decreases z\n\n\n",
        "output": "{\n    match z\n        case Zero => ZeroAddAssociative(Add(x, y), Zero);\n        case S(z') => AddAssociative(x, y, z');\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Append(head: T, tail: List)\n\ndatatype Nat = Zero | S(Pred: Nat)\n\nfunction Add(x: Nat, y: Nat) : Nat\n    decreases y\n\n{\n    match y\n        case Zero => x\n        case S(y') => S(Add(x, y')) \n}\n\nfunction Size(l: List<Nat>): Nat\n    decreases l\n\n{\n    if l.Nil? then Zero else S(Size(l.tail))\n}\n\nfunction Concatenation(l1: List<Nat>, l2: List<Nat>) : List<Nat>\n    decreases l1, l2\n\n{\n    match l1\n        case Nil => l2\n        case Append(head1, tail1) => \n            match l2\n                case Nil => l1\n                case Append(_, _) => Append(head1, Concatenation(tail1, l2))\n}\n\nKnown Properties:\nlemma ZeroAddNeutral(n: Nat)\n    ensures Add(n, Zero) == Add(Zero, n) == n\n\n{}\n\n\n\nProperty:\nlemma SizeOfConcatenationIsSumOfSizes(l1: List<Nat>, l2: List<Nat>)\n    ensures Size(Concatenation(l1, l2)) == Add(Size(l1), Size(l2))\n    decreases l1, l2\n\n\n",
        "output": "{\n    match l1\n        case Nil => {\n            ZeroAddNeutral(Size(l2));\n\n            assert Size(Concatenation(l1, l2))\n            == Size(Concatenation(Nil, l2))\n            == Size(l2)\n            == // ZeroAddNeutral\n            Add(Zero, Size(l2)) \n            == Add(Size(l1), Size(l2));\n        }\n        case Append(_, tail1) => match l2\n                                     case Nil => {\n                                        assert Size(Concatenation(l1, l2))\n                                        == Size(Concatenation(l1, Nil))\n                                        == Size(l1)\n                                        == Add(Size(l1), Zero)\n                                        == Add(Size(l1), Size(l2));\n                                     }\n                                     case Append(_, tail2) => SizeOfConcatenationIsSumOfSizes(tail1, tail2);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Append(head: T, tail: List)\n\ndatatype Nat = Zero | S(Pred: Nat)\n\nfunction Concatenation(l1: List<Nat>, l2: List<Nat>) : List<Nat>\n    decreases l1, l2\n\n{\n    match l1\n        case Nil => l2\n        case Append(head1, tail1) => \n            match l2\n                case Nil => l1\n                case Append(_, _) => Append(head1, Concatenation(tail1, l2))\n}\n\nfunction ReverseList(l: List<Nat>) : List<Nat>\n    decreases l\n\n{\n    if l.Nil? then Nil else Concatenation(ReverseList(l.tail), Append(l.head, Nil))\n}\n\nKnown Properties:\nlemma ReversalOfConcatenationWithHead(l: List<Nat>, n: Nat)\n    ensures ReverseList(Concatenation(l, Append(n, Nil))) == Append(n, ReverseList(l))\n    decreases l, n\n\n{}\n\n\n\nProperty:\nlemma DoubleReversalResultsInInitialList(l: List<Nat>)\n    ensures l == ReverseList(ReverseList(l))\n\n\n",
        "output": "{\n    match l\n        case Nil => {\n            assert ReverseList(ReverseList(l))\n            == ReverseList(ReverseList(Nil))\n            == ReverseList(Nil)\n            == Nil;\n\n            assert l == ReverseList(ReverseList(l));\n        }\n        case Append(head, tail) => {\n            ReversalOfConcatenationWithHead(ReverseList(tail), head);\n\n            assert ReverseList(ReverseList(l))\n            == ReverseList(ReverseList(Append(head, tail)))\n            == ReverseList(Concatenation(ReverseList(tail), Append(head, Nil)))\n            == Append(head, ReverseList(ReverseList(tail)))\n            == Append(head, tail)\n            == l;\n        }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction app<T>(l1: List<T>, l2: List<T>) : List<T>\n\n{\n    match l1\n    case Nil => l2\n    case Cons(x, l1') => Cons(x, app(l1', l2))\n}\n\nfunction rev<T> (l: List<T>) : List<T>\n\n{\n    match l\n    case Nil => Nil\n    case Cons(x, l') => app(rev(l'), Cons(x, Nil))\n}\n\nKnown Properties:\nlemma LR1<T> (l: List<T>, x: T)\n    ensures rev(app(l, Cons(x, Nil))) == Cons(x, rev(l))\n\n{}\n\n\n\nProperty:\nlemma RevRev<T>(l: List<T>)\n    ensures rev(rev(l)) == l\n\n\n",
        "output": "{\n    match l\n    case Nil => assert true;\n    case Cons(x, l') => {\n        assert rev(rev(l)) == rev(app(rev(l'), Cons(x, Nil)));\n        LR1(rev(l'), x);\n    }\n    \n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Nat = Zero | Succ(Pred: Nat)\n\nfunction add(m: Nat, n: Nat) : Nat\n    decreases m\n\n{\n    match m\n        case Zero => n\n        case Succ(m') => Succ(add(m', n))\n}\n\npredicate Odd(m: Nat)\n    decreases m\n\n{\n    match m\n        case Zero => false\n        case Succ(m') => Even(m')\n}\n\npredicate Even(m: Nat)\n    decreases m\n\n{\n    match m\n        case Zero => true\n        case Succ(m') => Odd(m')\n}\n\nKnown Properties:\n\n\nProperty:\nlemma SumMNIsEven(m: Nat, n: Nat)\n    requires Odd(m)\n    requires Odd(n)\n    ensures Even(add(m,n))\n\n\n",
        "output": "{\n    match m\n        case Succ(Zero) => assert Even(add(Succ(Zero),n));\n        case Succ(Succ(m')) => SumMNIsEven(m',n);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(x:int,e:nat):int\n\n{\n   if e == 0 then 1 else x * exp(x,e-1)    \n}\n\nKnown Properties:\n\n\nProperty:\nlemma div10_Lemma(n:nat)\n   requires n >= 3\n   ensures (exp(3,4*n)+9)%10 == 0\n\n\n",
        "output": "{\n   if n == 3 { \n      calc { \n         (exp(3,4*n)+9);\n         (exp(3,4*3)+9);\n      }\n   } else { \n         div10_Lemma(n-1);\n         var k := (exp(3,4*(n-1))+9) / 10;\n\n         calc {\n            exp(3, 4*n) + 9;\n            3 * 3 * exp(3,4*n - 2) + 9;\n            3 * 3 * 3 * 3 * exp(3,4*n - 4) + 9;\n         }\n   }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(x:int,e:nat):int\n\n{\n   if e == 0 then 1 else x * exp(x,e-1)    \n}\n\nKnown Properties:\nlemma div10_Lemma(n:nat)\n   requires n >= 3\n   ensures (exp(3,4*n)+9)%10 == 0\n\n{\n   if n == 3 { \n      calc { \n         (exp(3,4*n)+9);\n         (exp(3,4*3)+9);\n      }\n   } else { \n         div10_Lemma(n-1);\n         var k := (exp(3,4*(n-1))+9) / 10;\n\n         calc {\n            exp(3, 4*n) + 9;\n            3 * 3 * exp(3,4*n - 2) + 9;\n            3 * 3 * 3 * 3 * exp(3,4*n - 4) + 9;\n         }\n   }\n}\n\n\n\nProperty:\nlemma div10Forall_Lemma()\n   ensures forall n :: n>=3 ==> (exp(3,4*n)+9)%10==0\n\n\n",
        "output": "{\n   forall n | n>=3 {div10_Lemma(n);}\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(x:int,e:nat):int\n\n{\n   if e == 0 then 1 else x * exp(x,e-1)    \n}\n\nKnown Properties:\nlemma exp_Lemma(x:int, e:nat)\t\t\t\n    requires x >= 1 \n    ensures exp(x,e) >= 1\n\n{}\n\n\n\nProperty:\nlemma expPlus1_Lemma(x:int,n:nat)\n\trequires x >= 1 && n >= 1\n\tensures exp(x+1,n) >= exp(x,n) + 1 \n   \n\n",
        "output": "{\n      if n == 1 {\n      } else {\n         calc {\n            exp(x+1,n);\n            ==\n            (x + 1) * exp(x+1,n-1);\n            >= {\n               expPlus1_Lemma(x, n-1);\n            }\n            (x + 1) * (exp(x,n-1) + 1);\n            ==\n            x * exp(x,n-1) + x + exp(x,n-1) + 1;\n            ==\n            exp(x,n) + x + exp(x,n-1) + 1;\n            == \n            exp(x,n) + 1 + exp(x,n-1) + x;\n            >= \n            {\n               exp_Lemma(x, n-1);\n            }\n            exp(x,n) + 1;\n         }\n      }\n   }\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Reg = R0 | R1 | R2 | R3\n\nnewtype u32 = x:int | 0 <= x < 0x1_0000_0000\n\nnewtype i32 = x: int  | -0x8000_0000 <= x < 0x8000_0000\n\ndatatype Expr =\n    | Const(n: u32)\n        // overflow during addition is an error\n    | Add(r1: Reg, r2: Reg)\n        // this is saturating subtraction (to allow comparing numbers)\n    | Sub(r1: Reg, r2: Reg)\n\ndatatype Stmt =\n    | Assign(r: Reg, e: Expr)\n      // Jump by offset if condition is true\n    | JmpZero(r: Reg, offset: i32)\n\nfunction has_valid_jump_targets(ss: seq<Stmt>, from: nat): bool\n    decreases |ss|-from\n    requires from <= |ss|\n\n{\n    if from == |ss| then true\n    else (match ss[from] {\n            case JmpZero(_, offset) =>\n                0 <= from + offset as int <= |ss|\n            case _ => true\n            } &&\n            has_valid_jump_targets(ss, from+1))\n}\n\nghost predicate valid_jump_targets(ss: seq<Stmt>) \n\n{\n    forall i | 0 <= i < |ss| :: ss[i].JmpZero? ==> 0 <= i + ss[i].offset as int <= |ss|\n}\n\nKnown Properties:\nlemma has_valid_jump_targets_ok_helper(ss: seq<Stmt>, from: nat)\n    requires from <= |ss|\n    decreases |ss|-from\n    ensures has_valid_jump_targets(ss, from) <==>\n            (forall i | from <= i < |ss| :: ss[i].JmpZero? ==> 0 <= i + ss[i].offset as int <= |ss|)\n\n{}\n\n\n\nProperty:\nlemma has_valid_jump_targets_ok(ss: seq<Stmt>)\n    ensures has_valid_jump_targets(ss, 0) <==> valid_jump_targets(ss)\n\n\n",
        "output": "{\n    has_valid_jump_targets_ok_helper(ss, 0);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction power2(exp: nat) : nat\n    ensures power2(exp) > 0\n\n{\n    if (exp==0) then\n        1\n    else\n        2*power2(exp-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma lemma_power2_adds(e1:nat, e2:nat)\n    decreases e2\n    ensures power2(e1 + e2) == power2(e1) * power2(e2)\n\n\n",
        "output": "{\n    if (e2 == 0) {\n    } else {\n        lemma_power2_adds(e1, e2-1);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction power2(exp: nat) : nat\n    ensures power2(exp) > 0\n\n{\n    if (exp==0) then\n        1\n    else\n        2*power2(exp-1)\n}\n\nKnown Properties:\nlemma lemma_power2_adds(e1:nat, e2:nat)\n    decreases e2\n    ensures power2(e1 + e2) == power2(e1) * power2(e2)\n\n{\n    if (e2 == 0) {\n    } else {\n        lemma_power2_adds(e1, e2-1);\n    }\n}\n\nlemma bounded_mul_eq_0(x: int, m: int)\n  requires -m < m*x < m\n  ensures x == 0\n\n{}\n\nlemma lemma_div_ind(x: int, d: int)\n    requires d > 0\n    ensures x / d + 1 == (x + d) / d\n\n{\n    assert d * (x / d + 1)\n        == (x/d)*d + d\n        == x - (x % d) + d;\n\n    assert d * ((x + d) / d)\n        == (x + d) - ((x + d) % d);\n\n    assert -d < d * (x / d + 1) - d * ((x + d) / d) < d;\n    assert  d * (x / d + 1) - d * ((x + d) / d) == d * ((x / d + 1) - ((x + d) / d));\n\n    bounded_mul_eq_0((x / d + 1) - ((x + d) / d), d);\n}\n\nlemma lemma_div_multiples_vanish_fancy(x:int, b:int, d:int)\n    requires 0<d\n    requires 0<=b<d\n    ensures (d*x + b)/d == x\n    decreases if x > 0 then x else -x\n  \n{\n    if (x == 0) {\n    } else if (x > 0) {\n      lemma_div_multiples_vanish_fancy(x-1, b, d);\n      lemma_div_ind(d*(x-1) + b, d);\n    } else {\n      lemma_div_multiples_vanish_fancy(x+1, b, d);\n      lemma_div_ind(d*x + b, d);\n    }\n  }\n\nlemma lemma_div_by_multiple(b:int, d:int)\n    requires 0 < d\n    ensures  (b*d) / d == b\n\n{   \n    lemma_div_multiples_vanish_fancy(b, 0, d);\n}\n\n\n\nProperty:\nlemma lemma_power2_div_is_sub(x:int, y:int)\n    requires 0 <= x <= y\n    ensures power2(y - x) == power2(y) / power2(x) >= 0\n\n\n",
        "output": "{\n    calc {\n        power2(y) / power2(x);\n        { lemma_power2_adds(y-x, x); }\n        (power2(y-x)*power2(x)) / power2(x);\n        { lemma_div_by_multiple(power2(y-x), power2(x)); }\n        power2(y-x);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction sum(numbers: seq<real>): real\n\n{\n    if |numbers| == 0 then\n        0.0\n    else\n        numbers[0] + sum(numbers[1..])\n}\n\nfunction mean(numbers: seq<real>): real\n    requires numbers != []\n\n{\n    sum(numbers) / (|numbers| as real)\n}\n\nKnown Properties:\nlemma sum_nonnegative(numbers: seq<real>)\n    requires forall i :: 0 <= i < |numbers| ==> numbers[i] >= 0.0\n    ensures sum(numbers) >= 0.0\n\n{}\n\n\n\nProperty:\nlemma mean_nonnegative(numbers: seq<real>)\n    requires numbers != []\n    requires forall i :: 0 <= i < |numbers| ==> numbers[i] >= 0.0\n    ensures mean(numbers) >= 0.0\n\n\n",
        "output": "{\n    sum_nonnegative(numbers);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(x:int, e:nat):int\n\n{\n    if e == 0 then 1 else x * exp(x,e-1)\n}\n\nKnown Properties:\nlemma expGET1_Lemma(x:int, e:nat)\t\t\t\n    requires x >= 1 \n    ensures exp(x,e) >= 1\n\n{}\n\n\n\nProperty:\nlemma expMon_Lemma(x:int, n:nat)\n\trequires x >= 1 && n >= 1\n\tensures exp(x+1,n) >= exp(x,n) + 1 \n\n\n",
        "output": "{\n    if n != 1 { \n        calc {\n            exp(x+1,n);\n            >= \n            {\n                expGET1_Lemma(x,n-1);\n            }\n            x*(exp(x,n-1) + 1); \n            >=\n            exp(x,n)+1;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction IsEven(a : int) : bool\n    requires a >= 0\n\n{\n    if a == 0 then      true \n    else if a == 1 then false \n    else                IsEven(a - 2)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma EvenDouble(a: int)\n    requires a >= 0\n    ensures IsEven(a + a)\n\n\n",
        "output": "{\n    if a >= 2 {\n        EvenDouble(a - 2);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction IsEven(a : int) : bool\n    requires a >= 0\n\n{\n    if a == 0 then      true \n    else if a == 1 then false \n    else                IsEven(a - 2)\n}\n\nKnown Properties:\nlemma EvenDouble(a: int)\n    requires a >= 0\n    ensures IsEven(a + a)\n\n{\n    if a >= 2 {\n        EvenDouble(a - 2);\n    }\n}\n\nlemma EvenPlus(x: int, y: int)\n    requires x >= 0\n    requires y >= 0\n    requires IsEven(x)\n    requires IsEven(y)\n    ensures IsEven(x + y)\n\n{}\n\n\n\nProperty:\nlemma EvenSquare(a : int)\n    requires a >= 0\n    ensures IsEven(a) ==> IsEven(a * a)\n\n\n",
        "output": "{\n    if a >= 2 && IsEven(a) {\n        EvenSquare(a - 2);\n        assert a * a == (a - 2) * (a - 2) + 4 * a - 4;\n        EvenDouble(2 * a - 2);\n        EvenPlus((a - 2) * (a - 2), 4 * a - 4);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction pow2(n: nat): int\n\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nKnown Properties:\nlemma pow2unroll16(n: nat)\n    requires n >= 16\n    ensures pow2(n) == 0x10000 * pow2(n - 16)\n\n{}\n\nlemma pow2unroll8(n: nat)\n    requires n >= 8\n    ensures pow2(n) == 0x100 * pow2(n - 8)\n\n{}\n\nlemma pow2unroll4(n: nat)\n    requires n >= 4\n    ensures pow2(n) == 0x10 * pow2(n - 4)\n\n{}\n\n\n\nProperty:\nlemma pow2Bounds_2(n: nat)\n    requires n < 32\n    ensures 0 <= pow2(n) < 0x100000000\n\n\n",
        "output": "{\n    var k := n;\n    if k >= 16 {\n        pow2unroll16(k);\n        k := k - 16;\n    }\n    if k >= 8 {\n        pow2unroll8(k);\n        k := k - 8;\n    }\n    if k >= 4 {\n        pow2unroll4(k);\n        k := k - 4;\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction pow2(n: nat): int\n\n{\n  if n == 0 then 1 else 2 * pow2(n - 1)\n}\n\nKnown Properties:\nlemma pow2Monotone(a: nat, b: nat)\n    requires a < b\n    ensures pow2(a) < pow2(b)\n\n{}\n\n\n\nProperty:\nlemma pow2Bounds'''(n: nat)\n    requires n < 32\n    ensures 0 <= pow2(n) < 0x100000000\n\n\n",
        "output": "{\n    pow2Monotone(n, 32);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction SumUpto(A: array<real>, end: int): real\n    requires -1 <= end < A.Length\n    reads A\n\n{\n    if end == -1 then\n        0.0\n    else\n        A[end] + SumUpto(A, end-1)\n}\n\nfunction Sum(A: array<real>): real\n    reads A\n\n{\n  SumUpto(A, A.Length-1)\n}\n\nKnown Properties:\nlemma SumUpto_increase(A: array<real>, end1: int, end2: int)\n    requires forall i | 0 <= i < A.Length :: A[i] > 0.0\n    requires -1 <= end1 < A.Length\n    requires -1 <= end2 < A.Length\n    requires end1 < end2\n    ensures SumUpto(A, end1) < SumUpto(A, end2)\n\n{}\n\n\n\nProperty:\nlemma PercentileUniqueAnswer(p: real, A: array<real>, total: real, i1: int, i2: int)\n    requires forall i | 0 <= i < A.Length :: A[i] > 0.0\n    requires 0.0 <= p <= 100.0\n    requires total == Sum(A)\n    requires total > 0.0\n\n    requires -1 <= i1 < A.Length\n    requires SumUpto(A, i1) <= (p/100.0) * total\n    requires i1+1 < A.Length ==> SumUpto(A, i1+1) > (p/100.0) * total\n\n    requires -1 <= i2 < A.Length\n    requires SumUpto(A, i2) <= (p/100.0) * total\n    requires i2+1 < A.Length ==> SumUpto(A, i2+1) > (p/100.0) * total\n\n    decreases if i2 < i1 then 1 else 0  // wlog i1 <= i2\n\n    ensures i1 == i2\n\n\n",
        "output": "{\n    if i1+1< i2 {\n        SumUpto_increase(A, i1+1, i2);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype T<A> = Nil | Cons(head: T, tail: T<T>)\n\nfunction Length<A>(s: T<A>): int\n\n{\n    match s\n        case Nil => 0\n        case Cons(_, s) => 1 + Length(s)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma lemma_LengthGe0<A>(s: T<A>)\n    ensures 0 <= Length(s)\n\n\n",
        "output": "{\n    match s \n        case Nil => \n        case Cons(_, s) => lemma_LengthGe0(s);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction sumUp(nums: seq<int>): int \n{\n    if |nums| == 0 then 0 else nums[0]+sumUp(nums[1..])\n}\n\nKnown Properties:\n\n\nProperty:\nlemma sumUpLemma(a: seq<int>, b: seq<int>)\n  ensures sumUp(a + b) == sumUp(a) + sumUp(b)\n\n\n",
        "output": "{\n  if a == [] {\n     assert a + b == b;\n  }\n  else {\n    sumUpLemma(a[1..], b);\n    calc {\n      sumUp(a + b);\n      {\n        assert (a + b)[0] == a[0];\n        assert (a + b)[1..] == a[1..] + b;\n      }\n      a[0] + sumUp(a[1..] + b);\n      a[0] + sumUp(a[1..]) + sumUp(b);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction sum(nums: seq<int>): int \n{\n    if |nums| == 0 then 0 else sum(nums[0..(|nums|-1)])+nums[|nums|-1]\n}\n\nfunction sumUp(nums: seq<int>): int \n{\n    if |nums| == 0 then 0 else nums[0]+sumUp(nums[1..])\n}\n\nKnown Properties:\nlemma sumUpLemma(a: seq<int>, b: seq<int>)\n  ensures sumUp(a + b) == sumUp(a) + sumUp(b)\n\n{\n  if a == [] {\n     assert a + b == b;\n  }\n  else {\n    sumUpLemma(a[1..], b);\n    calc {\n      sumUp(a + b);\n      {\n        assert (a + b)[0] == a[0];\n        assert (a + b)[1..] == a[1..] + b;\n      }\n      a[0] + sumUp(a[1..] + b);\n      a[0] + sumUp(a[1..]) + sumUp(b);\n    }\n  }\n}\n\n\n\nProperty:\nlemma sumsEqual(nums: seq<int>)\n    decreases |nums|\n    ensures sum(nums) == sumUp(nums)\n\n\n",
        "output": "{\n  if nums == [] {}\n  else {\n    var ln := |nums|-1;\n    calc {\n      sumUp(nums[..]);\n      {\n        assert nums[..] == nums[0..ln] + [nums[ln]];\n        sumUpLemma(nums[0..ln], [nums[ln]]);\n      }\n      sumUp(nums[0..ln]) + sumUp([nums[ln]]);\n      sum(nums[0..ln]) + nums[ln];\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction nodeConcat(xs: ListNode, end: ListNode): ListNode \n{\n    if xs == Null then end else Node(xs.val, nodeConcat(xs.next, end))\n}\n\nfunction reverseList(xs: ListNode): ListNode\n\n{\n    if xs == Null then Null else nodeConcat(reverseList(xs.next), Node(xs.val, Null))\n}\n\nKnown Properties:\nlemma ConcatNullIsRightIdentity(xs: ListNode) \n    ensures xs == nodeConcat(xs, Null)\n\n{}\n\nlemma ConcatAssociative(xs: ListNode, ys: ListNode, zs: ListNode)\n    ensures nodeConcat(nodeConcat(xs, ys), zs) == nodeConcat(xs, nodeConcat(ys, zs))\n\n{}\n\n\n\nProperty:\nlemma ConcatReverseList(xs:ListNode, ys: ListNode) \n    ensures reverseList(nodeConcat(xs,ys)) == nodeConcat(reverseList(ys), reverseList(xs))\n    decreases xs\n\n\n",
        "output": "{\n    if xs == Null {\n        calc {\n            reverseList(nodeConcat(xs,ys));\n            reverseList(ys);\n            == \n            {ConcatNullIsRightIdentity(reverseList(ys));}\n            nodeConcat(reverseList(ys), Null);\n            nodeConcat(reverseList(ys), xs);\n            nodeConcat(reverseList(ys), reverseList(xs));\n        }\n    }else{\n        var x := Node(xs.val, Null);\n        calc {\n            reverseList(nodeConcat(xs, ys));\n            reverseList(nodeConcat(nodeConcat(x, xs.next), ys));\n            == \n            {ConcatAssociative(x, xs.next, ys);}\n            reverseList(nodeConcat(x, nodeConcat(xs.next, ys)));\n            nodeConcat(reverseList(nodeConcat(xs.next, ys)), x);\n            == {ConcatReverseList(xs.next, ys);}\n            nodeConcat(nodeConcat(reverseList(ys) , reverseList(xs.next)), x);\n            == \n            {ConcatAssociative(reverseList(ys), reverseList(xs.next), x);}\n            nodeConcat(reverseList(ys) , nodeConcat(reverseList(xs.next), x));\n            nodeConcat(reverseList(ys) , reverseList(xs));\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction nodeConcat(xs: ListNode, end: ListNode): ListNode \n{\n    if xs == Null then end else Node(xs.val, nodeConcat(xs.next, end))\n}\n\nfunction reverseList(xs: ListNode): ListNode\n\n{\n    if xs == Null then Null else nodeConcat(reverseList(xs.next), Node(xs.val, Null))\n}\n\nKnown Properties:\nlemma ConcatNullIsRightIdentity(xs: ListNode) \n    ensures xs == nodeConcat(xs, Null)\n\n{}\n\nlemma ConcatAssociative(xs: ListNode, ys: ListNode, zs: ListNode)\n    ensures nodeConcat(nodeConcat(xs, ys), zs) == nodeConcat(xs, nodeConcat(ys, zs))\n\n{}\n\nlemma ConcatReverseList(xs:ListNode, ys: ListNode) \n    ensures reverseList(nodeConcat(xs,ys)) == nodeConcat(reverseList(ys), reverseList(xs))\n    decreases xs\n\n{\n    if xs == Null {\n        calc {\n            reverseList(nodeConcat(xs,ys));\n            reverseList(ys);\n            == \n            {ConcatNullIsRightIdentity(reverseList(ys));}\n            nodeConcat(reverseList(ys), Null);\n            nodeConcat(reverseList(ys), xs);\n            nodeConcat(reverseList(ys), reverseList(xs));\n        }\n    }else{\n        var x := Node(xs.val, Null);\n        calc {\n            reverseList(nodeConcat(xs, ys));\n            reverseList(nodeConcat(nodeConcat(x, xs.next), ys));\n            == \n            {ConcatAssociative(x, xs.next, ys);}\n            reverseList(nodeConcat(x, nodeConcat(xs.next, ys)));\n            nodeConcat(reverseList(nodeConcat(xs.next, ys)), x);\n            == {ConcatReverseList(xs.next, ys);}\n            nodeConcat(nodeConcat(reverseList(ys) , reverseList(xs.next)), x);\n            == \n            {ConcatAssociative(reverseList(ys), reverseList(xs.next), x);}\n            nodeConcat(reverseList(ys) , nodeConcat(reverseList(xs.next), x));\n            nodeConcat(reverseList(ys) , reverseList(xs));\n        }\n    }\n}\n\n\n\nProperty:\nlemma reverseReverseListIsIdempotent(xs: ListNode)\n    ensures reverseList(reverseList(xs)) == xs\n\n\n",
        "output": "{\n    if xs == Null {\n\n    }else{\n        var x := Node(xs.val, Null);\n        calc {\n            reverseList(reverseList(xs));\n            reverseList(reverseList(nodeConcat(x, xs.next)));\n            == \n            {ConcatReverseList(x, xs.next);}\n            reverseList(nodeConcat(reverseList(xs.next), reverseList(x)));\n            reverseList(nodeConcat(reverseList(xs.next), x));\n            == \n            {ConcatReverseList(reverseList(xs.next),x);}\n            nodeConcat(reverseList(x), reverseList(reverseList(xs.next))); \n            nodeConcat(x, reverseList(reverseList(xs.next)));\n            nodeConcat(x, xs.next);\n            xs;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction reverse<A>(x: seq<A>): seq<A> \n\n{\n    if x == [] then [] else reverse(x[1..])+[x[0]]\n}\n\nKnown Properties:\n\n\nProperty:\nlemma reversePreservesMultiset<A>(xs: seq<A>) \n    ensures multiset(xs) == multiset(reverse(xs))\n\n\n",
        "output": "{\n    if xs == [] {\n\n    }else {\n        var x := xs[0];\n        assert xs == [x] + xs[1..];\n        assert multiset(xs) == multiset([x]) + multiset(xs[1..]);\n        assert reverse(xs) == reverse(xs[1..])+[x];\n        reversePreservesMultiset(xs[1..]);\n        assert multiset(xs[1..]) == multiset(reverse(xs[1..]));\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction reverse<A>(x: seq<A>): seq<A> \n\n{\n    if x == [] then [] else reverse(x[1..])+[x[0]]\n}\n\nKnown Properties:\n\n\nProperty:\nlemma ReverseConcat<T>(xs: seq<T>, ys: seq<T>)\n    ensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n\n\n",
        "output": "{\n    if |xs| == 0 {\n        assert xs + ys == ys;\n    } else {\n        assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction reverse<A>(x: seq<A>): (ret:seq<A>) \n    ensures |x| > 0 ==> (|ret| > 0 && ret[0] == x[|x|-1])\n\n{\n    if x == [] then [] else reverse(x[1..])+[x[0]]\n}\n\nKnown Properties:\nlemma ReverseConcat<T>(xs: seq<T>, ys: seq<T>)\n    ensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n\n{\n    if |xs| == 0 {\n        assert xs + ys == ys;\n    } else {\n        assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    }\n}\n\n\n\nProperty:\nlemma reverseRest<A>(xs: seq<A>)\n    requires |xs| > 0\n    ensures reverse(xs) == [xs[ |xs| -1 ] ] + reverse(xs[0..|xs|-1])\n\n\n",
        "output": "{\n    assert xs == xs[0..|xs|-1] + [xs[|xs|-1]];\n    assert reverse(xs) == [xs[ |xs| -1]] + reverse(xs)[1..];\n    calc {\n        reverse(xs);\n        reverse(xs[0..|xs|-1] + [xs[|xs|-1]]);\n        == \n        {ReverseConcat(xs[0..|xs|-1], [xs[ |xs|-1 ]]);}\n        reverse([xs[ |xs|-1 ]]) + reverse(xs[0..|xs|-1]);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction reverse<A>(x: seq<A>): (ret:seq<A>) \n    ensures |x| > 0 ==> (|ret| > 0 && ret[0] == x[|x|-1])\n\n{\n    if x == [] then [] else reverse(x[1..])+[x[0]]\n}\n\nKnown Properties:\nlemma ReverseIndexAll<T>(xs: seq<T>)\n    ensures |reverse(xs)| == |xs|\n    ensures forall i :: 0 <= i < |xs| ==> reverse(xs)[i] == xs[|xs| - i - 1]\n\n{}\n\n\n\nProperty:\nlemma ReverseIndex<T>(xs: seq<T>, i: int)\n    requires 0 <= i < |xs|\n    ensures |reverse(xs)| == |xs|\n    ensures reverse(xs)[i] == xs[|xs| - i - 1]\n\n\n",
        "output": "{\n    ReverseIndexAll(xs);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype ListNode = Null | Node(val: nat, next: ListNode)\n\nfunction reverse<A>(x: seq<A>): (ret:seq<A>) \n    ensures |x| > 0 ==> (|ret| > 0 && ret[0] == x[|x|-1])\n\n{\n    if x == [] then [] else reverse(x[1..])+[x[0]]\n}\n\nKnown Properties:\nlemma ReverseIndexAll<T>(xs: seq<T>)\n    ensures |reverse(xs)| == |xs|\n    ensures forall i :: 0 <= i < |xs| ==> reverse(xs)[i] == xs[|xs| - i - 1]\n\n{}\n\n\n\nProperty:\nlemma reverseReverseIdempotent<A>(xs: seq<A>) \n    ensures reverse(reverse(xs)) == xs\n\n\n",
        "output": "{\n    ReverseIndexAll(reverse(xs));\n    ReverseIndexAll(xs);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nfunction stepSum(xs: seq<Steps>): nat \n{\n    if xs == [] then 0 else (match xs[0] {\n        case One => 1\n        case Two => 2\n    } + stepSum(xs[1..]))\n}\n\nghost predicate stepEndsAt(xs: seq<Steps>, n: nat) \n{\n    stepSum(xs) == n\n}\n\nghost predicate allEndAtN(ss: set<seq<Steps> >, n: nat) \n{\n    forall xs ::  xs in ss ==> stepEndsAt(xs, n)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma stepBaseZero() \n    ensures exists ss: set< seq<Steps> > :: allEndAtN(ss, 0) && |ss| == 0\n\n\n",
        "output": "{\n    assert allEndAtN({[]}, 0);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nfunction stepSum(xs: seq<Steps>): nat \n{\n    if xs == [] then 0 else (match xs[0] {\n        case One => 1\n        case Two => 2\n    } + stepSum(xs[1..]))\n}\n\nghost predicate stepEndsAt(xs: seq<Steps>, n: nat) \n{\n    stepSum(xs) == n\n}\n\nghost predicate allEndAtN(ss: set<seq<Steps> >, n: nat) \n{\n    forall xs ::  xs in ss ==> stepEndsAt(xs, n)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma stepBaseOne() \n    ensures exists ss: set< seq<Steps> > :: allEndAtN(ss, 1) && |ss| == 1\n\n\n",
        "output": "{\n    assert allEndAtN({[One]}, 1);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nfunction stepSum(xs: seq<Steps>): nat \n{\n    if xs == [] then 0 else (match xs[0] {\n        case One => 1\n        case Two => 2\n    } + stepSum(xs[1..]))\n}\n\nghost predicate stepEndsAt(xs: seq<Steps>, n: nat) \n{\n    stepSum(xs) == n\n}\n\nghost predicate allEndAtN(ss: set<seq<Steps> >, n: nat) \n{\n    forall xs ::  xs in ss ==> stepEndsAt(xs, n)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma stepBaseTwo() \n    ensures exists ss: set< seq<Steps> > :: allEndAtN(ss, 2) && |ss| == 2\n\n\n",
        "output": "{\n    assert allEndAtN({[One,One], [Two]}, 2);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nghost function plusOne(x: seq<Steps>): seq<Steps> \n{\n    [One]+x\n}\n\nghost function addOne(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusOne(x) in addOne(ss)\n    ensures addOne(ss) == set x | x in ss :: plusOne(x)\n\n{\n    set x | x in ss :: plusOne(x)\n}\n\nKnown Properties:\nlemma UnequalSeqs<T>(xs: seq<T>, ys: seq<T>, someT: T)\n    requires xs != ys\n    ensures [someT]+xs != [someT]+ys\n\n{\n    if |xs| < |ys| {} else if |ys| > |xs| {}\n    else if i: nat :| i < |xs| && i <|ys| && xs[i] != ys[i] {\n        assert ([someT]+xs)[i+1] != ([someT]+ys)[i+1];\n    }\n}\n\n\n\nProperty:\nlemma plusOneNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusOne(x) !in addOne(ss)\n\n\n",
        "output": "{\n    if x == [] {\n        assert [] !in ss;\n        assert [One]+[] !in addOne(ss);\n    }\n    if plusOne(x) in addOne(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusOne(y) in addOne(ss)\n            ensures plusOne(y) != plusOne(x)\n        {\n            UnequalSeqs(x, y, One);\n            assert plusOne(y) != [One]+x;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nghost function plusOne(x: seq<Steps>): seq<Steps> \n{\n    [One]+x\n}\n\nghost function addOne(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusOne(x) in addOne(ss)\n    ensures addOne(ss) == set x | x in ss :: plusOne(x)\n\n{\n    set x | x in ss :: plusOne(x)\n}\n\nKnown Properties:\nlemma UnequalSeqs<T>(xs: seq<T>, ys: seq<T>, someT: T)\n    requires xs != ys\n    ensures [someT]+xs != [someT]+ys\n\n{\n    if |xs| < |ys| {} else if |ys| > |xs| {}\n    else if i: nat :| i < |xs| && i <|ys| && xs[i] != ys[i] {\n        assert ([someT]+xs)[i+1] != ([someT]+ys)[i+1];\n    }\n}\n\nlemma plusOneNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusOne(x) !in addOne(ss)\n\n{\n    if x == [] {\n        assert [] !in ss;\n        assert [One]+[] !in addOne(ss);\n    }\n    if plusOne(x) in addOne(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusOne(y) in addOne(ss)\n            ensures plusOne(y) != plusOne(x)\n        {\n            UnequalSeqs(x, y, One);\n            assert plusOne(y) != [One]+x;\n        }\n    }\n}\n\n\n\nProperty:\nlemma addOneSize(ss: set<seq<Steps>>)\n    ensures |addOne(ss)| == |ss|\n\n\n",
        "output": "{\n    var size := |ss|;\n    if x :| x in ss {\n        assert |ss - {x}| == size - 1;\n        addOneSize(ss - {x});\n        assert |addOne(ss-{x})| == size - 1;\n        assert addOne(ss) == addOne(ss-{x}) + {[One]+x};\n        assert x !in ss-{x};\n        plusOneNotIn(ss-{x}, x);\n        assert plusOne(x) !in addOne(ss-{x});\n        assert |addOne(ss)| == |addOne(ss-{x})| + |{[One]+x}|;\n    }else{\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nghost function plusTwo(x: seq<Steps>): seq<Steps> \n{\n    [Two]+x\n}\n\nghost function addTwo(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusTwo(x) in addTwo(ss)\n    ensures addTwo(ss) == set x | x in ss :: plusTwo(x)\n\n{\n    set x | x in ss :: plusTwo(x)\n}\n\nKnown Properties:\nlemma UnequalSeqs<T>(xs: seq<T>, ys: seq<T>, someT: T)\n    requires xs != ys\n    ensures [someT]+xs != [someT]+ys\n\n{\n    if |xs| < |ys| {} else if |ys| > |xs| {}\n    else if i: nat :| i < |xs| && i <|ys| && xs[i] != ys[i] {\n        assert ([someT]+xs)[i+1] != ([someT]+ys)[i+1];\n    }\n}\n\n\n\nProperty:\nlemma plusTwoNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusTwo(x) !in addTwo(ss)\n\n\n",
        "output": "{\n    if x == [] {\n        assert [] !in ss;\n        assert [Two]+[] !in addTwo(ss);\n    }\n    if plusTwo(x) in addTwo(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusTwo(y) in addTwo(ss)\n            ensures plusTwo(y) != plusTwo(x)\n        {\n            UnequalSeqs(x, y, Two);\n            assert plusTwo(y) != [Two]+x;\n        }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nghost function plusTwo(x: seq<Steps>): seq<Steps> \n{\n    [Two]+x\n}\n\nghost function addTwo(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusTwo(x) in addTwo(ss)\n    ensures addTwo(ss) == set x | x in ss :: plusTwo(x)\n\n{\n    set x | x in ss :: plusTwo(x)\n}\n\nKnown Properties:\nlemma UnequalSeqs<T>(xs: seq<T>, ys: seq<T>, someT: T)\n    requires xs != ys\n    ensures [someT]+xs != [someT]+ys\n\n{\n    if |xs| < |ys| {} else if |ys| > |xs| {}\n    else if i: nat :| i < |xs| && i <|ys| && xs[i] != ys[i] {\n        assert ([someT]+xs)[i+1] != ([someT]+ys)[i+1];\n    }\n}\n\nlemma plusTwoNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusTwo(x) !in addTwo(ss)\n\n{\n    if x == [] {\n        assert [] !in ss;\n        assert [Two]+[] !in addTwo(ss);\n    }\n    if plusTwo(x) in addTwo(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusTwo(y) in addTwo(ss)\n            ensures plusTwo(y) != plusTwo(x)\n        {\n            UnequalSeqs(x, y, Two);\n            assert plusTwo(y) != [Two]+x;\n        }\n    }\n}\n\n\n\nProperty:\nlemma addTwoSize(ss: set<seq<Steps>>)\n    ensures |addTwo(ss)| == |ss|\n\n\n",
        "output": "{\n    var size := |ss|;\n    if x :| x in ss {\n        addTwoSize(ss - {x});\n        assert addTwo(ss) == addTwo(ss-{x}) + {[Two]+x};\n        plusTwoNotIn(ss-{x}, x);\n        assert |addTwo(ss)| == |addTwo(ss-{x})| + |{[Two]+x}|;\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Steps = One | Two\n\nfunction stepSum(xs: seq<Steps>): nat \n{\n    if xs == [] then 0 else (match xs[0] {\n        case One => 1\n        case Two => 2\n    } + stepSum(xs[1..]))\n}\n\nghost predicate stepEndsAt(xs: seq<Steps>, n: nat) \n{\n    stepSum(xs) == n\n}\n\nghost predicate allEndAtN(ss: set<seq<Steps> >, n: nat) \n{\n    forall xs ::  xs in ss ==> stepEndsAt(xs, n)\n}\n\nghost function plusOne(x: seq<Steps>): seq<Steps> \n{\n    [One]+x\n}\n\nghost function addOne(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusOne(x) in addOne(ss)\n    ensures addOne(ss) == set x | x in ss :: plusOne(x)\n\n{\n    set x | x in ss :: plusOne(x)\n}\n\nghost function plusTwo(x: seq<Steps>): seq<Steps> \n{\n    [Two]+x\n}\n\nghost function addTwo(ss: set<seq<Steps>>): set<seq<Steps>> \n    ensures forall x :: x in ss ==> plusTwo(x) in addTwo(ss)\n    ensures addTwo(ss) == set x | x in ss :: plusTwo(x)\n\n{\n    set x | x in ss :: plusTwo(x)\n}\n\nKnown Properties:\nlemma UnequalSeqs<T>(xs: seq<T>, ys: seq<T>, someT: T)\n    requires xs != ys\n    ensures [someT]+xs != [someT]+ys\n\n{\n    if |xs| < |ys| {} else if |ys| > |xs| {}\n    else if i: nat :| i < |xs| && i <|ys| && xs[i] != ys[i] {\n        assert ([someT]+xs)[i+1] != ([someT]+ys)[i+1];\n    }\n}\n\nlemma plusOneNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusOne(x) !in addOne(ss)\n\n{\n    if x == [] {\n        assert [] !in ss;\n        assert [One]+[] !in addOne(ss);\n    }\n    if plusOne(x) in addOne(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusOne(y) in addOne(ss)\n            ensures plusOne(y) != plusOne(x)\n        {\n            UnequalSeqs(x, y, One);\n            assert plusOne(y) != [One]+x;\n        }\n    }\n}\n\nlemma addOneSize(ss: set<seq<Steps>>)\n    ensures |addOne(ss)| == |ss|\n\n{\n    var size := |ss|;\n    if x :| x in ss {\n        assert |ss - {x}| == size - 1;\n        addOneSize(ss - {x});\n        assert |addOne(ss-{x})| == size - 1;\n        assert addOne(ss) == addOne(ss-{x}) + {[One]+x};\n        assert x !in ss-{x};\n        plusOneNotIn(ss-{x}, x);\n        assert plusOne(x) !in addOne(ss-{x});\n        assert |addOne(ss)| == |addOne(ss-{x})| + |{[One]+x}|;\n    }else{\n\n    }\n}\n\nlemma plusTwoNotIn(ss: set<seq<Steps>>, x: seq<Steps>)\n    requires x !in ss\n    ensures plusTwo(x) !in addTwo(ss)\n\n{\n    if x == [] {\n        assert [] !in ss;\n        assert [Two]+[] !in addTwo(ss);\n    }\n    if plusTwo(x) in addTwo(ss) {\n        forall y | y in ss \n            ensures y != x\n            ensures plusTwo(y) in addTwo(ss)\n            ensures plusTwo(y) != plusTwo(x)\n        {\n            UnequalSeqs(x, y, Two);\n            assert plusTwo(y) != [Two]+x;\n        }\n    }\n}\n\nlemma addTwoSize(ss: set<seq<Steps>>)\n    ensures |addTwo(ss)| == |ss|\n\n{\n    var size := |ss|;\n    if x :| x in ss {\n        addTwoSize(ss - {x});\n        assert addTwo(ss) == addTwo(ss-{x}) + {[Two]+x};\n        plusTwoNotIn(ss-{x}, x);\n        assert |addTwo(ss)| == |addTwo(ss-{x})| + |{[Two]+x}|;\n    }\n}\n\n\n\nProperty:\nlemma stepSetsAdd(i: nat, steps: array<nat>) \n    requires i >= 2\n    requires steps.Length >= i+1\n    requires forall k: nat :: k < i ==> exists ss: set< seq<Steps> > :: steps[k] == |ss| && allEndAtN(ss, k)\n    ensures exists sp : set< seq<Steps> > :: |sp| == steps[i-1] + steps[i-2] && allEndAtN(sp, i)\n\n\n",
        "output": "{\n    var oneStepBack :| steps[i-1] == |oneStepBack| && allEndAtN(oneStepBack, i-1);\n    var twoStepBack :| steps[i-2] == |twoStepBack| && allEndAtN(twoStepBack, i-2);\n    var stepForward := addOne(oneStepBack);\n    var stepTwoForward := addTwo(twoStepBack);\n    assert forall x :: x in stepForward ==> x[0] == One;\n    addOneSize(oneStepBack);\n    addTwoSize(twoStepBack);\n    var sumSet := stepForward + stepTwoForward;\n    assert |sumSet| == steps[i-1]+steps[i-2];\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction total (a: seq<nat>) : nat\n\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\n\nKnown Properties:\n\n\nProperty:\nlemma total_lemma(a: seq<nat>, i:nat) \n  requires |a| > 0\n  requires 0 <= i < |a|\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1])\n\n\n",
        "output": "{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ncodatatype Stream<T> = Nil | Cons(head: T, tail: Stream)\n\ngreatest predicate StreamOfNonEmpties(M: Stream<Stream>)\n\n{\n  match M\n  case Nil => true\n  case Cons(s, N) => s.Cons? && StreamOfNonEmpties(N)\n}\n\nghost function Prepend<T>(x: T, M: Stream<Stream>): Stream<Stream>\n\n{\n  match M\n  case Nil => Nil\n  case Cons(s, N) => Cons(Cons(x, s), Prepend(x, N))\n}\n\nghost function PrependThenFlattenStartMarker<T>(prefix: Stream, M: Stream<Stream>, startMarker: T): Stream\n\n{\n  match prefix\n  case Cons(hd, tl) =>\n    Cons(hd, PrependThenFlattenStartMarker(tl, M, startMarker))\n  case Nil =>\n    match M\n    case Nil => Nil\n    case Cons(s, N) => Cons(startMarker, PrependThenFlattenStartMarker(s, N, startMarker))\n}\n\nghost function FlattenStartMarker<T>(M: Stream<Stream>, startMarker: T): Stream\n\n{\n  PrependThenFlattenStartMarker(Nil, M, startMarker)\n}\n\nghost function PrependThenFlattenNonEmpties(prefix: Stream, M: Stream<Stream>): Stream\n  requires StreamOfNonEmpties(M)\n\n{\n  match prefix\n  case Cons(hd, tl) =>\n    Cons(hd, PrependThenFlattenNonEmpties(tl, M))\n  case Nil =>\n    match M\n    case Nil => Nil\n    case Cons(s, N) => Cons(s.head, PrependThenFlattenNonEmpties(s.tail, N))\n}\n\nghost function FlattenNonEmpties(M: Stream<Stream>): Stream\n  requires StreamOfNonEmpties(M)\n\n{\n  PrependThenFlattenNonEmpties(Nil, M)\n}\n\nmethod can be called from functions,\n                                          // this condition is used as an antecedent here\n        PrependThenFlattenStartMarker(prefix, M, startMarker) == PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M))\n\n{}\n\nmethod can be called from functions,\n                                        // this condition is used as an antecedent here\n        FlattenStartMarker(M, startMarker) == FlattenNonEmpties(Prepend(startMarker, M))\n\n{\n    Lemma_Flatten(Nil, M, startMarker);\n}\n\nKnown Properties:\ngreatest lemma Lemma_Flatten<T>(prefix: Stream, M: Stream<Stream>, startMarker: T)\n    ensures StreamOfNonEmpties(Prepend(startMarker, M)) ==> // always holds, on account of Prepend_Lemma;\n                                          // but until (co-)method can be called from functions,\n                                          // this condition is used as an antecedent here\n        PrependThenFlattenStartMarker(prefix, M, startMarker) == PrependThenFlattenNonEmpties(prefix, Prepend(startMarker, M))\n\n{}\n\n\n\nProperty:\nlemma Theorem_Flatten<T>(M: Stream<Stream>, startMarker: T)\n    ensures StreamOfNonEmpties(Prepend(startMarker, M)) ==> // always holds, on account of Prepend_Lemma;\n                                        // but until (co-)method can be called from functions,\n                                        // this condition is used as an antecedent here\n        FlattenStartMarker(M, startMarker) == FlattenNonEmpties(Prepend(startMarker, M))\n\n\n",
        "output": "{\n    Lemma_Flatten(Nil, M, startMarker);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function length(xs: List): nat\n\n{\n    match xs\n    case Nil => 0\n    case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n    match xs\n    case Nil => ys\n    case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nghost function rev(xs: List): List\n\n{\n    match xs\n    case Nil => Nil\n    case Cons(x, rest) => append(rev(rest), Cons(x, Nil))\n}\n\nKnown Properties:\nlemma AppendLength(xs: List, ys: List)\n  ensures length(append(xs, ys)) == length(xs) + length(ys)\n\n{}\n\n\n\nProperty:\nlemma RevLength(xs: List)\n    ensures length(rev(xs)) == length(xs)\n\n\n",
        "output": "{\n    match xs {\n        case Nil =>\n        case Cons(x, rest) =>\n            calc {\n            length(append(rev(rest), Cons(x, Nil)));\n            { AppendLength(rev(rest), Cons(x, Nil)); }\n            length(rev(rest)) + length(Cons(x, Nil));\n            length(rev(rest)) + 1;\n            }\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nKnown Properties:\nlemma XtrLength<T(00)>(mp: List<int>, lst: List)\n  ensures length(xtr(mp, lst)) == length(mp)\n\n{}\n\n\n\nProperty:\nlemma NthXtr<T(00)>(i: int, mp: List<int>, lst: List<T>)\n  requires 0 <= i < length(mp)\n  ensures nth(i, xtr(mp, lst)) == nth(nth(i, mp), lst)\n\n\n",
        "output": "{\n  XtrLength(mp, lst);\n  assert nth(i, xtr(mp, lst)) == nthWorker(i, xtr(mp, lst));\n  if i == 0 {\n  } else {\n    calc {\n      nth(i-1, xtr(mp, lst).tail);\n      // def. xtr\n      nth(i-1, xtr(mp.tail, lst));\n      { NthXtr(i-1, mp.tail, lst); }\n      nth(nth(i-1, mp.tail), lst);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nats(n: nat): List<int>\n\n{\n  if n == 0 then Nil else Cons(n-1, nats(n-1))\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nKnown Properties:\nlemma NatsLength(n: nat)\n  ensures length(nats(n)) == n\n\n{}\n\nlemma NthNatsWorker(i: int, n: nat)\n  requires 0 <= i < n && length(nats(n)) == n\n  ensures nthWorker(i, nats(n)) == n - 1 - i\n\n{}\n\n\n\nProperty:\nlemma NthNats(i: int, n: nat)\n  requires 0 <= i < n\n  ensures nth(i, nats(n)) == n - 1 - i\n\n\n",
        "output": "{\n  NatsLength(n);\n  NthNatsWorker(i, n);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nKnown Properties:\n\n\nProperty:\nlemma NthAppendA<T(00)>(i: int, xs: List, ys: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, append(xs, ys)) == nth(i, xs)\n\n\n",
        "output": "{\n  if i == 0 {\n    calc {\n      nth(0, append(xs, ys));\n      nth(0, Cons(xs.head, append(xs.tail, ys)));\n      xs.head;\n    }\n  } else {\n    calc {\n      nth(i, append(xs, ys));\n      nth(i, Cons(xs.head, append(xs.tail, ys)));\n      nth(i-1, append(xs.tail, ys));\n      { NthAppendA(i-1, xs.tail, ys); }\n      nth(i-1, xs.tail);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nKnown Properties:\n\n\nProperty:\nlemma NthAppendB<T(00)>(i: int, xs: List, ys: List)\n  requires length(xs) <= i < length(xs) + length(ys)\n  ensures nth(i, append(xs, ys)) == nth(i - length(xs), ys)\n\n\n",
        "output": "{\n  match xs {\n    case Nil =>\n      assert nth(i, append(xs, ys)) == nth(i, ys);\n    case Cons(x, rest) =>\n      calc {\n        nth(i, append(xs, ys));\n        nth(i, append(Cons(x, rest), ys));\n        // def. append\n        nth(i, Cons(x, append(rest, ys)));\n        nth(i-1, append(rest, ys));\n        { NthAppendB(i-1, rest, ys); }\n        nth(i-1 - length(rest), ys);\n      }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nghost function rev(xs: List): List\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, rest) => append(rev(rest), Cons(x, Nil))\n}\n\nKnown Properties:\nlemma AppendLength(xs: List, ys: List)\n  ensures length(append(xs, ys)) == length(xs) + length(ys)\n\n{}\n\nlemma RevLength(xs: List)\n    ensures length(rev(xs)) == length(xs)\n\n{\n    match xs {\n        case Nil =>\n        case Cons(x, rest) =>\n            calc {\n            length(append(rev(rest), Cons(x, Nil)));\n            { AppendLength(rev(rest), Cons(x, Nil)); }\n            length(rev(rest)) + length(Cons(x, Nil));\n            length(rev(rest)) + 1;\n            }\n    }\n}\n\nlemma NthAppendA<T(00)>(i: int, xs: List, ys: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, append(xs, ys)) == nth(i, xs)\n\n{\n  if i == 0 {\n    calc {\n      nth(0, append(xs, ys));\n      nth(0, Cons(xs.head, append(xs.tail, ys)));\n      xs.head;\n    }\n  } else {\n    calc {\n      nth(i, append(xs, ys));\n      nth(i, Cons(xs.head, append(xs.tail, ys)));\n      nth(i-1, append(xs.tail, ys));\n      { NthAppendA(i-1, xs.tail, ys); }\n      nth(i-1, xs.tail);\n    }\n  }\n}\n\nlemma NthAppendB<T(00)>(i: int, xs: List, ys: List)\n  requires length(xs) <= i < length(xs) + length(ys)\n  ensures nth(i, append(xs, ys)) == nth(i - length(xs), ys)\n\n{\n  match xs {\n    case Nil =>\n      assert nth(i, append(xs, ys)) == nth(i, ys);\n    case Cons(x, rest) =>\n      calc {\n        nth(i, append(xs, ys));\n        nth(i, append(Cons(x, rest), ys));\n        // def. append\n        nth(i, Cons(x, append(rest, ys)));\n        nth(i-1, append(rest, ys));\n        { NthAppendB(i-1, rest, ys); }\n        nth(i-1 - length(rest), ys);\n      }\n  }\n}\n\n\n\nProperty:\nlemma NthRev<T(00)>(i: int, xs: List)\n  requires 0 <= i < length(xs) == length(rev(xs))\n  ensures nthWorker(i, rev(xs)) == nthWorker(length(xs) - 1 - i, xs)\n\n\n",
        "output": "{\n  reveal nth();\n  assert xs.Cons?;\n  assert 1 <= length(rev(xs)) && rev(xs).Cons?;\n  RevLength(xs.tail);\n  if i < length(rev(xs.tail)) {\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendA(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i, rev(xs.tail));\n      { NthRev(i, xs.tail); }  // induction hypothesis\n      nthWorker(length(xs.tail) - 1 - i, xs.tail);\n      // def. nthWorker\n      nthWorker(length(xs.tail) - 1 - i + 1, xs);\n      nthWorker(length(xs) - 1 - i, xs);\n    }\n  } else {\n    assert i == length(rev(xs.tail));\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendB(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i - length(rev(xs.tail)), Cons(xs.head, Nil));\n      nthWorker(0, Cons(xs.head, Nil));\n      nthWorker(0, xs);\n      nthWorker(length(xs) - 1 - length(xs.tail), xs);\n      nthWorker(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - i, xs);\n    }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nghost function nats(n: nat): List<int>\n\n{\n  if n == 0 then Nil else Cons(n-1, nats(n-1))\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nghost function rev(xs: List): List\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, rest) => append(rev(rest), Cons(x, Nil))\n}\n\nKnown Properties:\nlemma XtrLength<T(00)>(mp: List<int>, lst: List)\n  ensures length(xtr(mp, lst)) == length(mp)\n\n{}\n\nlemma NthXtr<T(00)>(i: int, mp: List<int>, lst: List<T>)\n  requires 0 <= i < length(mp)\n  ensures nth(i, xtr(mp, lst)) == nth(nth(i, mp), lst)\n\n{\n  XtrLength(mp, lst);\n  assert nth(i, xtr(mp, lst)) == nthWorker(i, xtr(mp, lst));\n  if i == 0 {\n  } else {\n    calc {\n      nth(i-1, xtr(mp, lst).tail);\n      // def. xtr\n      nth(i-1, xtr(mp.tail, lst));\n      { NthXtr(i-1, mp.tail, lst); }\n      nth(nth(i-1, mp.tail), lst);\n    }\n  }\n}\n\nlemma NatsLength(n: nat)\n  ensures length(nats(n)) == n\n\n{}\n\nlemma NthNatsWorker(i: int, n: nat)\n  requires 0 <= i < n && length(nats(n)) == n\n  ensures nthWorker(i, nats(n)) == n - 1 - i\n\n{}\n\nlemma NthNats(i: int, n: nat)\n  requires 0 <= i < n\n  ensures nth(i, nats(n)) == n - 1 - i\n\n{\n  NatsLength(n);\n  NthNatsWorker(i, n);\n}\n\nlemma AppendLength(xs: List, ys: List)\n  ensures length(append(xs, ys)) == length(xs) + length(ys)\n\n{}\n\nlemma RevLength(xs: List)\n  ensures length(rev(xs)) == length(xs)\n\n{\n    match xs {\n        case Nil =>\n        case Cons(x, rest) =>\n            calc {\n            length(append(rev(rest), Cons(x, Nil)));\n            { AppendLength(rev(rest), Cons(x, Nil)); }\n            length(rev(rest)) + length(Cons(x, Nil));\n            length(rev(rest)) + 1;\n            }\n    }\n}\n\nlemma NthAppendA<T(00)>(i: int, xs: List, ys: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, append(xs, ys)) == nth(i, xs)\n\n{\n  if i == 0 {\n    calc {\n      nth(0, append(xs, ys));\n      nth(0, Cons(xs.head, append(xs.tail, ys)));\n      xs.head;\n    }\n  } else {\n    calc {\n      nth(i, append(xs, ys));\n      nth(i, Cons(xs.head, append(xs.tail, ys)));\n      nth(i-1, append(xs.tail, ys));\n      { NthAppendA(i-1, xs.tail, ys); }\n      nth(i-1, xs.tail);\n    }\n  }\n}\n\nlemma NthAppendB<T(00)>(i: int, xs: List, ys: List)\n  requires length(xs) <= i < length(xs) + length(ys)\n  ensures nth(i, append(xs, ys)) == nth(i - length(xs), ys)\n\n{\n  match xs {\n    case Nil =>\n      assert nth(i, append(xs, ys)) == nth(i, ys);\n    case Cons(x, rest) =>\n      calc {\n        nth(i, append(xs, ys));\n        nth(i, append(Cons(x, rest), ys));\n        // def. append\n        nth(i, Cons(x, append(rest, ys)));\n        nth(i-1, append(rest, ys));\n        { NthAppendB(i-1, rest, ys); }\n        nth(i-1 - length(rest), ys);\n      }\n  }\n}\n\nlemma NthRev<T(00)>(i: int, xs: List)\n  requires 0 <= i < length(xs) == length(rev(xs))\n  ensures nthWorker(i, rev(xs)) == nthWorker(length(xs) - 1 - i, xs)\n\n{\n  assert xs.Cons?;\n  assert 1 <= length(rev(xs)) && rev(xs).Cons?;\n  RevLength(xs.tail);\n  if i < length(rev(xs.tail)) {\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendA(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i, rev(xs.tail));\n      { NthRev(i, xs.tail); }  // induction hypothesis\n      nthWorker(length(xs.tail) - 1 - i, xs.tail);\n      // def. nthWorker\n      nthWorker(length(xs.tail) - 1 - i + 1, xs);\n      nthWorker(length(xs) - 1 - i, xs);\n    }\n  } else {\n    assert i == length(rev(xs.tail));\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendB(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i - length(rev(xs.tail)), Cons(xs.head, Nil));\n      nthWorker(0, Cons(xs.head, Nil));\n      nthWorker(0, xs);\n      nthWorker(length(xs) - 1 - length(xs.tail), xs);\n      nthWorker(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - i, xs);\n    }\n  }\n}\n\n\n\nProperty:\nlemma ExtractorLemma<T(00)>(i: int, xs: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, xtr(nats(length(xs)), xs)) == nth(i, rev(xs))\n\n\n",
        "output": "{\n  calc {\n    nth(i, xtr(nats(length(xs)), xs));\n    { NatsLength(length(xs));\n      NthXtr(i, nats(length(xs)), xs); }\n    nth(nth(i, nats(length(xs))), xs);\n    { NthNats(i, length(xs)); }\n    nth(length(xs) - 1 - i, xs);\n    { RevLength(xs); NthRev(i, xs); }\n    nth(i, rev(xs));\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nKnown Properties:\n\n\nProperty:\nlemma EqualElementsMakeEqualLists<T(00)>(xs: List, ys: List)\n  requires length(xs) == length(ys)\n  requires forall i :: 0 <= i < length(xs) ==> nth(i, xs) == nth(i, ys)\n  ensures xs == ys\n\n\n",
        "output": "{\n  match xs {\n    case Nil =>\n    case Cons(x, rest) =>\n      assert nth(0, xs) == nth(0, ys);\n      forall i | 0 <= i < length(xs.tail)\n      {\n        calc {\n          nth(i, xs.tail) == nth(i, ys.tail);\n          nth(i+1, Cons(xs.head, xs.tail)) == nth(i+1, Cons(ys.head, ys.tail));\n          nth(i+1, xs) == nth(i+1, ys);\n        }\n      }\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype List<T> = Nil | Cons(head: T, tail: List)\n\nghost function xtr<T(00)>(mp: List<int>, lst: List): List\n\n{\n  match mp\n  case Nil => Nil\n  case Cons(n, rest) => Cons(nth(n, lst), xtr(rest, lst))\n}\n\nghost function length(xs: List): nat\n\n{\n  match xs\n  case Nil => 0\n  case Cons(_, rest) => 1 + length(rest)\n}\n\nghost function nthWorker<T>(n: int, xs: List<T>): T\n  requires 0 <= n < length(xs)\n\n{\n  if n == 0 then xs.head else nthWorker(n-1, xs.tail)\n}\n\nghost function nth<T(00)>(n: int, xs: List<T>): T\n\n{\n  if 0 <= n < length(xs) then\n    nthWorker(n, xs)\n  else\n    var t :| true; t\n}\n\nghost function nats(n: nat): List<int>\n\n{\n  if n == 0 then Nil else Cons(n-1, nats(n-1))\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, rest) => Cons(x, append(rest, ys))\n}\n\nghost function rev(xs: List): List\n\n{\n  match xs\n  case Nil => Nil\n  case Cons(x, rest) => append(rev(rest), Cons(x, Nil))\n}\n\nKnown Properties:\nlemma XtrLength<T(00)>(mp: List<int>, lst: List)\n  ensures length(xtr(mp, lst)) == length(mp)\n\n{}\n\nlemma NthXtr<T(00)>(i: int, mp: List<int>, lst: List<T>)\n  requires 0 <= i < length(mp)\n  ensures nth(i, xtr(mp, lst)) == nth(nth(i, mp), lst)\n\n{\n  XtrLength(mp, lst);\n  assert nth(i, xtr(mp, lst)) == nthWorker(i, xtr(mp, lst));\n  if i == 0 {\n  } else {\n    calc {\n      nth(i-1, xtr(mp, lst).tail);\n      // def. xtr\n      nth(i-1, xtr(mp.tail, lst));\n      { NthXtr(i-1, mp.tail, lst); }\n      nth(nth(i-1, mp.tail), lst);\n    }\n  }\n}\n\nlemma NatsLength(n: nat)\n  ensures length(nats(n)) == n\n\n{}\n\nlemma NthNatsWorker(i: int, n: nat)\n  requires 0 <= i < n && length(nats(n)) == n\n  ensures nthWorker(i, nats(n)) == n - 1 - i\n\n{}\n\nlemma NthNats(i: int, n: nat)\n  requires 0 <= i < n\n  ensures nth(i, nats(n)) == n - 1 - i\n\n{\n  NatsLength(n);\n  NthNatsWorker(i, n);\n}\n\nlemma AppendLength(xs: List, ys: List)\n  ensures length(append(xs, ys)) == length(xs) + length(ys)\n\n{}\n\nlemma RevLength(xs: List)\n  ensures length(rev(xs)) == length(xs)\n\n{\n    match xs {\n        case Nil =>\n        case Cons(x, rest) =>\n            calc {\n            length(append(rev(rest), Cons(x, Nil)));\n            { AppendLength(rev(rest), Cons(x, Nil)); }\n            length(rev(rest)) + length(Cons(x, Nil));\n            length(rev(rest)) + 1;\n            }\n    }\n}\n\nlemma NthAppendA<T(00)>(i: int, xs: List, ys: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, append(xs, ys)) == nth(i, xs)\n\n{\n  if i == 0 {\n    calc {\n      nth(0, append(xs, ys));\n      nth(0, Cons(xs.head, append(xs.tail, ys)));\n      xs.head;\n    }\n  } else {\n    calc {\n      nth(i, append(xs, ys));\n      nth(i, Cons(xs.head, append(xs.tail, ys)));\n      nth(i-1, append(xs.tail, ys));\n      { NthAppendA(i-1, xs.tail, ys); }\n      nth(i-1, xs.tail);\n    }\n  }\n}\n\nlemma NthAppendB<T(00)>(i: int, xs: List, ys: List)\n  requires length(xs) <= i < length(xs) + length(ys)\n  ensures nth(i, append(xs, ys)) == nth(i - length(xs), ys)\n\n{\n  match xs {\n    case Nil =>\n      assert nth(i, append(xs, ys)) == nth(i, ys);\n    case Cons(x, rest) =>\n      calc {\n        nth(i, append(xs, ys));\n        nth(i, append(Cons(x, rest), ys));\n        // def. append\n        nth(i, Cons(x, append(rest, ys)));\n        nth(i-1, append(rest, ys));\n        { NthAppendB(i-1, rest, ys); }\n        nth(i-1 - length(rest), ys);\n      }\n  }\n}\n\nlemma NthRev<T(00)>(i: int, xs: List)\n  requires 0 <= i < length(xs) == length(rev(xs))\n  ensures nthWorker(i, rev(xs)) == nthWorker(length(xs) - 1 - i, xs)\n\n{\n  assert xs.Cons?;\n  assert 1 <= length(rev(xs)) && rev(xs).Cons?;\n  RevLength(xs.tail);\n  if i < length(rev(xs.tail)) {\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendA(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i, rev(xs.tail));\n      { NthRev(i, xs.tail); }  // induction hypothesis\n      nthWorker(length(xs.tail) - 1 - i, xs.tail);\n      // def. nthWorker\n      nthWorker(length(xs.tail) - 1 - i + 1, xs);\n      nthWorker(length(xs) - 1 - i, xs);\n    }\n  } else {\n    assert i == length(rev(xs.tail));\n    calc {\n      nth(i, rev(xs));\n      nthWorker(i, rev(xs));\n      // def. rev\n      nthWorker(i, append(rev(xs.tail), Cons(xs.head, Nil)));\n      { NthAppendB(i, rev(xs.tail), Cons(xs.head, Nil)); }\n      nthWorker(i - length(rev(xs.tail)), Cons(xs.head, Nil));\n      nthWorker(0, Cons(xs.head, Nil));\n      nthWorker(0, xs);\n      nthWorker(length(xs) - 1 - length(xs.tail), xs);\n      nthWorker(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - length(rev(xs.tail)), xs);\n      nth(length(xs) - 1 - i, xs);\n    }\n  }\n}\n\nlemma ExtractorLemma<T(00)>(i: int, xs: List)\n  requires 0 <= i < length(xs)\n  ensures nth(i, xtr(nats(length(xs)), xs)) == nth(i, rev(xs))\n\n{\n  calc {\n    nth(i, xtr(nats(length(xs)), xs));\n    { NatsLength(length(xs));\n      NthXtr(i, nats(length(xs)), xs); }\n    nth(nth(i, nats(length(xs))), xs);\n    { NthNats(i, length(xs)); }\n    nth(length(xs) - 1 - i, xs);\n    { RevLength(xs); NthRev(i, xs); }\n    nth(i, rev(xs));\n  }\n}\n\nlemma EqualElementsMakeEqualLists<T(00)>(xs: List, ys: List)\n  requires length(xs) == length(ys)\n  requires forall i :: 0 <= i < length(xs) ==> nth(i, xs) == nth(i, ys)\n  ensures xs == ys\n\n{\n  match xs {\n    case Nil =>\n    case Cons(x, rest) =>\n      assert nth(0, xs) == nth(0, ys);\n      forall i | 0 <= i < length(xs.tail)\n      {\n        calc {\n          nth(i, xs.tail) == nth(i, ys.tail);\n          nth(i+1, Cons(xs.head, xs.tail)) == nth(i+1, Cons(ys.head, ys.tail));\n          nth(i+1, xs) == nth(i+1, ys);\n        }\n      }\n  }\n}\n\n\n\nProperty:\nlemma ExtractorTheorem<T(00)>(xs: List)\n  ensures xtr(nats(length(xs)), xs) == rev(xs)\n\n\n",
        "output": "{\n  var a, b := xtr(nats(length(xs)), xs), rev(xs);\n  calc {\n    length(a);\n    { XtrLength(nats(length(xs)), xs); }\n    length(nats(length(xs)));\n    { NatsLength(length(xs)); }\n    length(xs);\n  }\n  calc {\n    length(xs);\n    { RevLength(xs); }\n    length(b);\n  }\n  forall i | 0 <= i < length(xs)\n    ensures nth(i, a) == nth(i, b)\n  {\n    reveal nth();\n    ExtractorLemma(i, xs);\n  }\n  EqualElementsMakeEqualLists(a, b);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ntype vname = string\ntype val = int\ntype state = vname -> val\n\ndatatype aexp = N(n: int) | V(vname) | Plus(aexp, aexp)  // arithmetic expressions\n\nghost function aval(a: aexp, s: state): val\n\n{\n  match a\n  case N(n) => n\n  case V(x) => s(x)\n  case Plus(a0, a1) => aval(a0, s) + aval(a1, s)\n}\n\nghost function plus(a0: aexp, a1: aexp): aexp\n\n{\n  if a0.N? && a1.N? then\n    N(a0.n + a1.n)\n  else if a0.N? then\n    if a0.n == 0 then a1 else Plus(a0, a1)\n  else if a1.N? then\n    if a1.n == 0 then a0 else Plus(a0, a1)\n  else\n    Plus(a0, a1)\n}\n\nghost function asimp(a: aexp): aexp\n\n{\n  match a\n  case N(n) => a\n  case V(x) => a\n  case Plus(a0, a1) => plus(asimp(a0), asimp(a1))\n}\n\nKnown Properties:\n\n\nProperty:\nlemma AsimpCorrect(a: aexp, s: state)\n  ensures aval(asimp(a), s) == aval(a, s)\n\n\n",
        "output": "{\n  // call the induction hypothesis on every value a' that is structurally smaller than a\n  forall a' | a' < a { AsimpCorrect(a', s); }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ntype vname = string  // variable names\ndatatype aexp = N(n: int) | V(vname) | Plus(aexp, aexp)  // arithmetic expressions\n\ntype val = int\ntype state = vname -> val\n\ndatatype bexp = Bc(v: bool) | Not(bexp) | And(bexp, bexp) | Less(aexp, aexp)\n\nghost function aval(a: aexp, s: state): val\n\n{\n  match a\n  case N(n) => n\n  case V(x) => s(x)\n  case Plus(a0, a1) => aval(a0, s) + aval(a1, s)\n}\n\nghost function bval(b: bexp, s: state): bool\n\n{\n  match b\n  case Bc(v) => v\n  case Not(b) => !bval(b, s)\n  case And(b0, b1) => bval(b0, s) && bval(b1, s)\n  case Less(a0, a1) => aval(a0, s) < aval(a1, s)\n}\n\nghost function not(b: bexp): bexp\n\n{\n  match b\n  case Bc(b0) => Bc(!b0)\n  case Not(b0) => b0  // this case is not in the Nipkow and Klein book, but it seems a nice one to include\n  case And(_, _) => Not(b)\n  case Less(_, _) => Not(b)\n}\n\nghost function and(b0: bexp, b1: bexp): bexp\n\n{\n  if b0.Bc? then\n    if b0.v then b1 else b0\n  else if b1.Bc? then\n    if b1.v then b0 else b1\n  else\n    And(b0, b1)\n}\n\nghost function less(a0: aexp, a1: aexp): bexp\n\n{\n  if a0.N? && a1.N? then\n    Bc(a0.n < a1.n)\n  else\n    Less(a0, a1)\n}\n\nghost function plus(a0: aexp, a1: aexp): aexp\n\n{\n  if a0.N? && a1.N? then\n    N(a0.n + a1.n)\n  else if a0.N? then\n    if a0.n == 0 then a1 else Plus(a0, a1)\n  else if a1.N? then\n    if a1.n == 0 then a0 else Plus(a0, a1)\n  else\n    Plus(a0, a1)\n}\n\nghost function asimp(a: aexp): aexp\n\n{\n  match a\n  case N(n) => a\n  case V(x) => a\n  case Plus(a0, a1) => plus(asimp(a0), asimp(a1))\n}\n\nghost function bsimp(b: bexp): bexp\n\n{\n  match b\n  case Bc(v) => b\n  case Not(b0) => not(bsimp(b0))\n  case And(b0, b1) => and(bsimp(b0), bsimp(b1))\n  case Less(a0, a1) => less(asimp(a0), asimp(a1))\n}\n\nKnown Properties:\nlemma AsimpCorrect(a: aexp, s: state)\n  ensures aval(asimp(a), s) == aval(a, s)\n\n{\n  // call the induction hypothesis on every value a' that is structurally smaller than a\n  forall a' | a' < a { AsimpCorrect(a', s); }\n}\n\n\n\nProperty:\nlemma BsimpCorrect(b: bexp, s: state)\n  ensures bval(bsimp(b), s) == bval(b, s)\n\n\n",
        "output": "{\n    forall b' | b' < b { BsimpCorrect(b', s); }\n    forall a { AsimpCorrect(a, s); }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ntype val = int\ntype state = vname -> val\ntype vname = string  // variable names\ndatatype aexp = N(n: int) | V(vname) | Plus(aexp, aexp)  // arithmetic expressions\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\ntype stack = List<val>\ndatatype instr = LOADI(val) | LOAD(vname) | ADD\n\nghost function exec1(i: instr, s: state, stk: stack): stack\n\n{\n  match i\n  case LOADI(n) => Cons(n, stk)\n  case LOAD(x) => Cons(s(x), stk)\n  case ADD =>\n    if stk.Cons? && stk.tail.Cons? then\n      var Cons(a1, Cons(a0, tail)) := stk;\n      Cons(a0 + a1, tail)\n    else  // stack underflow\n      Nil  // an alternative would be to return Cons(n, Nil) for an arbitrary value n--that is what Nipkow and Klein do\n}\n\nghost function exec(ii: List<instr>, s: state, stk: stack): stack\n\n{\n  match ii\n  case Nil => stk\n  case Cons(i, rest) => exec(rest, s, exec1(i, s, stk))\n}\n\nghost function append(xs: List, ys: List): List\n\n{\n  match xs\n  case Nil => ys\n  case Cons(x, tail) => Cons(x, append(tail, ys))\n}\n\nghost function comp(a: aexp): List<instr>\n\n{\n  match a\n  case N(n) => Cons(LOADI(n), Nil)\n  case V(x) => Cons(LOAD(x), Nil)\n  case Plus(a0, a1) => append(append(comp(a0), comp(a1)), Cons(ADD, Nil))\n}\n\nghost function aval(a: aexp, s: state): val\n\n{\n  match a\n  case N(n) => n\n  case V(x) => s(x)\n  case Plus(a0, a1) => aval(a0, s) + aval(a1, s)\n}\n\nKnown Properties:\nlemma ExecAppend(ii0: List<instr>, ii1: List<instr>, s: state, stk: stack)\n  ensures exec(append(ii0, ii1), s, stk) == exec(ii1, s, exec(ii0, s, stk))\n\n{}\n\n\n\nProperty:\nlemma CorrectCompilation(a: aexp, s: state, stk: stack)\n  ensures exec(comp(a), s, stk) == Cons(aval(a, s), stk)\n\n\n",
        "output": "{\n  match a\n  case N(n) =>\n  case V(x) =>\n  case Plus(a0, a1) =>\n    // This proof spells out the proof as a series of equality-preserving steps.  Each\n    // expression in the calculation is terminated by a semi-colon.  In some cases, a hint\n    // for the step is needed.  Such hints are given in curly braces.\n    calc {\n      exec(comp(a), s, stk);\n      // definition of comp on Plus\n      exec(append(append(comp(a0), comp(a1)), Cons(ADD, Nil)), s, stk);\n      { ExecAppend(append(comp(a0), comp(a1)), Cons(ADD, Nil), s, stk); }\n      exec(Cons(ADD, Nil), s, exec(append(comp(a0), comp(a1)), s, stk));\n      { ExecAppend(comp(a0), comp(a1), s, stk); }\n      exec(Cons(ADD, Nil), s, exec(comp(a1), s, exec(comp(a0), s, stk)));\n      { CorrectCompilation(a0, s, stk); }\n      exec(Cons(ADD, Nil), s, exec(comp(a1), s, Cons(aval(a0, s), stk)));\n      { CorrectCompilation(a1, s, Cons(aval(a0, s), stk)); }\n      exec(Cons(ADD, Nil), s, Cons(aval(a1, s), Cons(aval(a0, s), stk)));\n      // definition of comp on ADD\n      Cons(aval(a1, s) + aval(a0, s), stk);\n      // definition of aval on Plus\n      Cons(aval(a, s), stk);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nghost predicate IsPrime(n: int)\n\n{\n  2 <= n && forall m :: 2 <= m < n ==> n % m != 0 // WISH It would be great to think about the status of modulo as a trigger\n}\n\nghost predicate AllPrimes(s: set<int>, bound: int)\n\n{\n  // s contains only primes\n  (forall x :: x in s ==> IsPrime(x)) &&\n  // every prime up to \"bound\" is included in s\n  (forall p :: IsPrime(p) && p <= bound ==> p in s)\n}\n\nghost function PickLargest(s: set<int>): int\n  requires s != \n{}\n\nghost function product(s: set<int>): int\n\n{\n  if s == {} then 1 else\n  var a := PickLargest(s); a * product(s - {a})\n}\n\nKnown Properties:\nlemma LargestElementExists(s: set<int>)\n  requires s != \n{}\n\n\n\nProperty:\nlemma RemoveFactor(x: int, s: set<int>)\n  requires x in s\n  ensures product(s) == x * product(s - \n\n",
        "output": "{x}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(b: nat, n: nat): nat \n{\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma exp_sum(b: nat, n1: nat, n2: nat)\n  ensures exp(b, n1 + n2) == exp(b, n1) * exp(b, n2)\n\n\n",
        "output": "{\n  if n1 == 0 {\n  } else {\n    exp_sum(b, n1-1, n2);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction exp(b: nat, n: nat): nat \n{\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nKnown Properties:\nlemma exp_sum(b: nat, n1: nat, n2: nat)\n  ensures exp(b, n1 + n2) == exp(b, n1) * exp(b, n2)\n\n{\n  if n1 == 0 {\n  } else {\n    exp_sum(b, n1-1, n2);\n  }\n}\n\n\n\nProperty:\nlemma exp_sum_auto(b: nat)\n  ensures forall n1: nat, n2: nat :: exp(b, n1 + n2) == exp(b, n1) * exp(b, n2)\n\n\n",
        "output": "{\n  forall n1: nat, n2: nat\n    ensures exp(b, n1 + n2) == exp(b, n1) * exp(b, n2) {\n    exp_sum(b, n1, n2);\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction from_bits(s: seq<bool>): nat \n{\n  if s == [] then 0\n  else (if s[0] then 1 else 0) + 2 * from_bits(s[1..])\n}\n\nfunction exp(b: nat, n: nat): nat \n{\n  if n == 0 then 1\n  else b * exp(b, n-1)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma from_bits_append(s: seq<bool>, b: bool)\n  ensures from_bits(s + [b]) == from_bits(s) + exp(2, |s|) * (if b then 1 else 0)\n\n\n",
        "output": "{\n  if s == [] {\n    return;\n  }\n  assert s == [s[0]] + s[1..];\n  from_bits_append(s[1..], b);\n \n  assert (s + [b])[1..] == s[1..] + [b]; // observe\n  assert from_bits(s + [b]) == (if s[0] then 1 else 0) + 2 * from_bits(s[1..] + [b]);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction seq_sum(s: seq<int>) : (sum: int)\n\n{\n    if s == [] then\n        0\n    else\n        var x := s[0];\n        var remaining := s[1..];\n        x + seq_sum(remaining)\n}\n\nKnown Properties:\n\n\nProperty:\nlemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n    requires s == s1 + s2\n    ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n\n\n",
        "output": "{\n    if s == [] {\n        assert s1 == [];\n        assert s2 == [];\n    } else if s1 == [] {\n        assert s2 == s;\n    } else {\n        var x := s1[0];\n        var s1' := s1[1..];\n        assert s == [x] + s1' + s2;\n        SeqPartsSameSum(s[1..], s1[1..], s2);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction seq_sum(s: seq<int>) : (sum: int)\n\n{\n    if s == [] then\n        0\n    else\n        var x := s[0];\n        var remaining := s[1..];\n        x + seq_sum(remaining)\n}\n\nKnown Properties:\nlemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n    requires s == s1 + s2\n    ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n\n{\n    if s == [] {\n        assert s1 == [];\n        assert s2 == [];\n    } else if s1 == [] {\n        assert s2 == s;\n    } else {\n        var x := s1[0];\n        var s1' := s1[1..];\n        assert s == [x] + s1' + s2;\n        SeqPartsSameSum(s[1..], s1[1..], s2);\n    }\n}\n\n\n\nProperty:\nlemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n    requires multiset(s1) == multiset(s2)\n    ensures seq_sum(s1) == seq_sum(s2)\n\n\n",
        "output": "{\n    if s1 == [] {\n        assert s2 == [];\n    } else {\n        var x :| x in s1;\n        assert x in s1;\n        assert multiset(s1)[x] > 0;\n        assert multiset(s2)[x] > 0;\n        assert x in s2;\n        var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\n\n        var remaining1 := s1[..i1] + s1[i1+1..];\n        assert s1 == s1[..i1] + s1[i1..];\n        assert s1 == s1[..i1] + [x] + s1[i1+1..];\n        assert seq_sum(s1) == seq_sum(s1[..i1] + [x] + s1[i1+1..]);\n        SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n        SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n        assert seq_sum(s1) == seq_sum(s1[..i1]) + x + seq_sum(s1[i1+1..]);\n        SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n        assert multiset(s1) == multiset(remaining1 + [x]);\n        assert seq_sum(s1) == seq_sum(remaining1) + x;\n        assert multiset(s1) == multiset(remaining1) + multiset([x]);\n        assert multiset(s1) - multiset([x]) == multiset(remaining1);\n\n        var remaining2 := s2[..i2] + s2[i2+1..];\n        assert s2 == s2[..i2] + s2[i2..];\n        assert s2 == s2[..i2] + [x] + s2[i2+1..];\n        assert seq_sum(s2) == seq_sum(s2[..i2] + [x] + s2[i2+1..]);\n        SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n        SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n        assert seq_sum(s2) == seq_sum(s2[..i2]) + x + seq_sum(s2[i2+1..]);\n        SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n        assert multiset(s2) == multiset(remaining2 + [x]);\n        assert seq_sum(s2) == seq_sum(remaining2) + x;\n        assert multiset(s2) == multiset(remaining2) + multiset([x]);\n        assert multiset(s2) - multiset([x]) == multiset(remaining2);\n\n        DifferentPermutationSameSum(remaining1, remaining2);\n        assert seq_sum(remaining1) == seq_sum(remaining2);\n        assert seq_sum(s1) == seq_sum(s2);\n    }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\nfunction fact(n: nat) : nat\n\n{\n  if n==0 then 1 else n*fact(n-1)\n}\n\nfunction factAcc(n: nat,a: int) : int\n  decreases n\n\n{\n  if (n == 0) then a else factAcc(n-1,n*a)\n}\n\nfunction factAlt(n: nat) : int \n{ factAcc(n,1) }\n\nKnown Properties:\nlemma factAcc_correct(n: nat,a: int)\n  ensures factAcc(n,a) == fact(n)*a\n\n{}\n\n\n\nProperty:\nlemma equiv(n: nat)\n  ensures fact(n) == factAlt(n) \n\n\n",
        "output": "{\n  factAcc_correct(n, 1);\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Tree<V> = Leaf(V) | SingleNode(V, Tree<V>) | DoubleNode(V, Tree<V>, Tree<V>)\n\ndatatype Code<V> = CLf(V) | CSNd(V) | CDNd(V)\n\nfunction serialise<V>(t : Tree<V>) : seq<Code<V>> \n  decreases t \n\n{\n  match t {\n    case Leaf(v) => [ CLf(v) ]\n    case SingleNode(v, t) => serialise(t) + [ CSNd(v) ]\n    case DoubleNode(v, t1, t2) => serialise(t2) + serialise(t1) + [ CDNd(v) ]\n  }\n}\n\nfunction deserialiseAux<T>(codes: seq<Code<T>>, trees: seq<Tree<T>>): seq<Tree<T>>\n  requires |codes| > 0 || |trees| > 0\n  ensures |deserialiseAux(codes, trees)| >= 0\n  decreases codes\n\n{\n  if |codes| == 0 then trees\n  else\n    match codes[0] {\n      case CLf(v) => deserialiseAux(codes[1..], trees + [Leaf(v)])\n      case CSNd(v) => if (|trees| >= 1) then deserialiseAux(codes[1..], trees[..|trees|-1] + [SingleNode(v, trees[|trees|-1])]) else trees\n      case CDNd(v) => if (|trees| >= 2) then deserialiseAux(codes[1..], trees[..|trees|-2] + [DoubleNode(v, trees[|trees|-1], trees[|trees|-2])]) else trees\n    }\n}\n\nKnown Properties:\n\n\nProperty:\nlemma DeserialisetAfterSerialiseLemma<T> (t : Tree<T>, cds : seq<Code<T>>, ts : seq<Tree<T>>) \n  ensures deserialiseAux(serialise(t) + cds, ts) == deserialiseAux(cds, ts + [t])\n  \n\n",
        "output": "{\n    match t{\n      case Leaf(x) =>\n        calc{\n          deserialiseAux(serialise(t) + cds, ts);\n          ==\n            deserialiseAux([CLf(x)] + cds, ts);\n          == \n            deserialiseAux(cds, ts + [Leaf(x)]);\n          == \n            deserialiseAux(cds, ts + [t]);\n        }\n      case SingleNode(x,t1) =>\n        assert serialise(t1) + [ CSNd(x) ] + cds ==  serialise(t1) + ([ CSNd(x) ] + cds);\n        calc{\n          deserialiseAux(serialise(t) + cds, ts);\n          ==\n            deserialiseAux( serialise(t1) + [CSNd(x)] + cds ,ts); \n          ==\n            deserialiseAux((serialise(t1) + [CSNd(x)] + cds),ts);\n          == { DeserialisetAfterSerialiseLemma(t1 , [ CSNd(x) ], ts); }\n            deserialiseAux(serialise(t1)+ [CSNd(x)]  + cds, ts );\n          ==\n            deserialiseAux( ([CSNd(x)] + cds), ts + [ t1 ]);\n          == \n            deserialiseAux(cds, ts + [SingleNode(x,t1)]);\n          == \n            deserialiseAux(cds, ts + [t]); \n        }\n      case DoubleNode(x,t1,t2) =>\n        assert serialise(t2) + serialise(t1) + [ CDNd(x) ] + cds == serialise(t2) + (serialise(t1) + [ CDNd(x) ] + cds);\n        assert serialise(t1) + [CDNd(x)] + cds == serialise(t1) + ([CDNd(x)] + cds); \n        assert  (ts + [ t2 ]) +  [ t1 ] == ts + [t2,t1];\n        calc{\n          deserialiseAux(serialise(t) + cds, ts);\n          ==\n            deserialiseAux(serialise(t2) + serialise(t1) + [CDNd(x)] + cds ,ts); \n          ==\n            deserialiseAux(serialise(t2) + (serialise(t1) + [CDNd(x)] + cds),ts);\n          == { DeserialisetAfterSerialiseLemma(t2, serialise(t1) + [ CDNd(x) ], ts); }\n            deserialiseAux(serialise(t1)+ [CDNd(x)]  + cds, ts + [ t2 ]);\n          ==\n            deserialiseAux(serialise(t1) + ([CDNd(x)] + cds), ts + [ t2 ]);\n          == { DeserialisetAfterSerialiseLemma(t1, [ CDNd(x) ] + cds, ts + [ t2 ]); }\n            deserialiseAux([ CDNd(x) ] + cds, (ts + [ t2 ]) + [t1]);\n          ==\n            deserialiseAux([ CDNd(x) ] + cds, ts + [t2, t1]);\n          == \n            deserialiseAux([CDNd(x)] + cds, ts + [t2 , t1]);\n          == \n            deserialiseAux(cds, ts + [DoubleNode(x,t1,t2)]); \n          == \n            deserialiseAux(cds, ts + [t]);\n        }\n    }\n  }\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Tree<V> = Leaf(V) | SingleNode(V, Tree<V>) | DoubleNode(V, Tree<V>, Tree<V>)\n\ndatatype Code<V> = CLf(V) | CSNd(V) | CDNd(V)\n\nfunction serialise<V>(t : Tree<V>) : seq<Code<V>> \n  decreases t \n\n{\n  match t {\n    case Leaf(v) => [ CLf(v) ]\n    case SingleNode(v, t) => serialise(t) + [ CSNd(v) ]\n    case DoubleNode(v, t1, t2) => serialise(t2) + serialise(t1) + [ CDNd(v) ]\n  }\n}\n\nfunction deserialiseAux<T>(codes: seq<Code<T>>, trees: seq<Tree<T>>): seq<Tree<T>>\n  requires |codes| > 0 || |trees| > 0\n  ensures |deserialiseAux(codes, trees)| >= 0\n  decreases codes\n\n{\n  if |codes| == 0 then trees\n  else\n    match codes[0] {\n      case CLf(v) => deserialiseAux(codes[1..], trees + [Leaf(v)])\n      case CSNd(v) => if (|trees| >= 1) then deserialiseAux(codes[1..], trees[..|trees|-1] + [SingleNode(v, trees[|trees|-1])]) else trees\n      case CDNd(v) => if (|trees| >= 2) then deserialiseAux(codes[1..], trees[..|trees|-2] + [DoubleNode(v, trees[|trees|-1], trees[|trees|-2])]) else trees\n    }\n}\n\nfunction deserialise<T>(s:seq<Code<T>>):seq<Tree<T>>\n  requires |s| > 0\n\n{\n  deserialiseAux(s, [])\n}\n\nKnown Properties:\nlemma DeserialisetAfterSerialiseLemma<T> (t : Tree<T>, cds : seq<Code<T>>, ts : seq<Tree<T>>) \n  ensures deserialiseAux(serialise(t) + cds, ts) == deserialiseAux(cds, ts + [t])\n\n{\n  match t{\n    case Leaf(x) =>\n      calc{\n        deserialiseAux(serialise(t) + cds, ts);\n        ==\n          deserialiseAux([CLf(x)] + cds, ts);\n        == \n          deserialiseAux(cds, ts + [Leaf(x)]);\n        == \n          deserialiseAux(cds, ts + [t]);\n      }\n    case SingleNode(x,t1) =>\n      assert serialise(t1) + [ CSNd(x) ] + cds ==  serialise(t1) + ([ CSNd(x) ] + cds);\n      calc{\n        deserialiseAux(serialise(t) + cds, ts);\n        ==\n          deserialiseAux( serialise(t1) + [CSNd(x)] + cds ,ts); \n        ==\n          deserialiseAux((serialise(t1) + [CSNd(x)] + cds),ts);\n        == { DeserialisetAfterSerialiseLemma(t1 , [ CSNd(x) ], ts); }\n          deserialiseAux(serialise(t1)+ [CSNd(x)]  + cds, ts );\n        ==\n          deserialiseAux( ([CSNd(x)] + cds), ts + [ t1 ]);\n        == \n          deserialiseAux(cds, ts + [SingleNode(x,t1)]);\n        == \n          deserialiseAux(cds, ts + [t]); \n      }\n    case DoubleNode(x,t1,t2) =>\n      assert serialise(t2) + serialise(t1) + [ CDNd(x) ] + cds == serialise(t2) + (serialise(t1) + [ CDNd(x) ] + cds);\n      assert serialise(t1) + [CDNd(x)] + cds == serialise(t1) + ([CDNd(x)] + cds); \n      assert  (ts + [ t2 ]) +  [ t1 ] == ts + [t2,t1];\n      calc{\n        deserialiseAux(serialise(t) + cds, ts);\n        ==\n          deserialiseAux(serialise(t2) + serialise(t1) + [CDNd(x)] + cds ,ts); \n        ==\n          deserialiseAux(serialise(t2) + (serialise(t1) + [CDNd(x)] + cds),ts);\n        == { DeserialisetAfterSerialiseLemma(t2, serialise(t1) + [ CDNd(x) ], ts); }\n          deserialiseAux(serialise(t1)+ [CDNd(x)]  + cds, ts + [ t2 ]);\n        ==\n          deserialiseAux(serialise(t1) + ([CDNd(x)] + cds), ts + [ t2 ]);\n        == { DeserialisetAfterSerialiseLemma(t1, [ CDNd(x) ] + cds, ts + [ t2 ]); }\n          deserialiseAux([ CDNd(x) ] + cds, (ts + [ t2 ]) + [t1]);\n        ==\n          deserialiseAux([ CDNd(x) ] + cds, ts + [t2, t1]);\n        == \n          deserialiseAux([CDNd(x)] + cds, ts + [t2 , t1]);\n        == \n          deserialiseAux(cds, ts + [DoubleNode(x,t1,t2)]); \n        == \n          deserialiseAux(cds, ts + [t]);\n      }\n  }\n}\n\n\n\nProperty:\nlemma SerialiseLemma<V>(t: Tree<V>)\n  ensures deserialise(serialise(t)) == [t]\n\n\n",
        "output": "{\n  assert serialise(t) + [] == serialise(t);\n\n  calc{\n    deserialise(serialise(t));\n    ==\n    deserialise(serialise(t) + []);\n    ==\n    deserialiseAux(serialise(t) + [], []);\n    == { DeserialisetAfterSerialiseLemma(t, [], []); }\n    deserialiseAux([],[] + [t]);\n    ==\n    deserialiseAux([],[t]);\n    == \n    [t];\n  }\n}\n\n"
    },
    {
        "instruction": "Provide the Dafny proof for the following property.",
        "input": "Model:\ndatatype Op = Mul | Add\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\ndatatype Expr = Const(nat)\n              | Var(string)\n              | Node(op: Op, args: List<Expr>)\n\nfunction Unit(op: Op): nat \n\n{\n  match op case Add => 0 case Mul => 1\n}\n\nfunction EvalList(op: Op, args: List<Expr>, env: map<string, nat>): nat\n  decreases args, op, env\n\n{\n  match args {\n    case Nil => Unit(op)\n    case Cons(e, tail) =>\n      var v0, v1 := Eval(e, env), EvalList(op, tail, env);\n      match op\n      case Add => v0 + v1\n      case Mul => v0 * v1\n  }\n}\n\nfunction Eval(e: Expr, env: map<string, nat>): nat\n\n{\n  match e {\n    case Const(c) => c\n    case Var(s) => if s in env then env[s] else 0\n    case Node(op, args) => EvalList(op, args, env)\n  }\n}\n\nfunction SubstituteList(es: List<Expr>, n: string, c: nat): List<Expr>\n\n{\n  match es\n  case Nil => Nil\n  case Cons(head, tail) => Cons(Substitute(head, n, c), SubstituteList(tail, n, c))\n}\n\nfunction Substitute(e: Expr, n: string, c: nat): Expr\n\n{\n  match e\n  case Const(_) => e\n  case Var(s) => if s == n then Const(c) else e\n  case Node(op, args) => Node(op, SubstituteList(args, n, c))\n}\n\nKnown Properties:\n\n\nProperty:\nlemma EvalSubstituteListCorrect(op: Op, args: List<Expr>, n: string, c: nat, env: map<string, nat>)\n  ensures EvalList(op, SubstituteList(args, n, c), env) == EvalList(op, args, env[n := c])\n  decreases args, op, n, c, env\n\n\n",
        "output": "{\n  match args\n  case Nil => {}\n  case Cons(head, tail) => {\n    // Ex 5.15\n    calc {\n      EvalList(op, SubstituteList(args, n, c), env);\n    ==  // defn SubstituteList\n      EvalList(op, Cons(Substitute(head, n, c), SubstituteList(tail, n, c)), env);\n    == // unfold defn EvalList\n      EvalList(op, Cons(Substitute(head, n, c), SubstituteList(tail, n, c)), env);\n    ==\n      (match op\n       case Add => Eval(Substitute(head, n, c), env) + EvalList(op, SubstituteList(tail, n, c), env)\n       case Mul => Eval(Substitute(head, n, c), env) * EvalList(op, SubstituteList(tail, n, c), env));\n      (match op\n       case Add => Eval(head, env[n := c]) + EvalList(op, SubstituteList(tail, n, c), env)\n       case Mul => Eval(head, env[n := c]) * EvalList(op, SubstituteList(tail, n, c), env));\n    == \n    // { EvalSubstituteListCorrect(op, tail, n, c, env); }\n      (match op\n       case Add => Eval(head, env[n := c]) + EvalList(op, tail, env[n := c])\n       case Mul => Eval(head, env[n := c]) * EvalList(op, tail, env[n := c]));\n    == // fold defn Eval/EvalList\n      EvalList(op, args, env[n := c]);\n    }\n  }\n}\n\n"
    }
]